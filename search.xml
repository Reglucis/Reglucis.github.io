<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>html多级列表</title>
      <link href="/2025/09/05/html%E5%A4%9A%E7%BA%A7%E5%88%97%E8%A1%A8/"/>
      <url>/2025/09/05/html%E5%A4%9A%E7%BA%A7%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="方法">方法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>li element</span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>sub li element<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>sub li element<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>sub li element<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>li element<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">li</span>&gt;</span>li element</span><br><span class="line">    <span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>sub li element<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>sub li element<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span>&gt;</span>sub li element<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">ol</span>&#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">counter-reset</span>: item </span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">li</span>&#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">display</span>: block</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"><span class="selector-tag">li</span><span class="selector-pseudo">:before</span> &#123;</span></span><br><span class="line"><span class="language-css"><span class="attribute">content</span>: <span class="built_in">counters</span>(item, <span class="string">&quot;.&quot;</span>) <span class="string">&quot; &quot;</span>; </span></span><br><span class="line"><span class="language-css"><span class="attribute">counter-increment</span>: item</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="效果">效果</h2><ol><li>li element<ol><li>sub li element</li><li>sub li element</li><li>sub li element</li></ol></li><li>li element</li><li>li element<ol><li>sub li element</li><li>sub li element</li><li>sub li element</li></ol></li></ol><style>ol{    counter-reset: item }li{    display: block}li:before {    content: counters(item, ".") " ";     counter-increment: item}</style><h2 id="节标题的改造">节标题的改造</h2><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">  <span class="attribute">counter-increment</span>: counter_h1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="built_in">counter</span>(counter_h1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="参考文献">参考文献</h2><p>https://stackoverflow.com/questions/4098195/can-ordered-list-produce-result-that-looks-like-1-1-1-2-1-3-instead-of-just-1</p>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在 markdown 的 html 块内使用 markdown 语法</title>
      <link href="/2025/09/05/md-html/"/>
      <url>/2025/09/05/md-html/</url>
      
        <content type="html"><![CDATA[<p>本文转载自<ahref="https://www.zhihu.com/question/53311539/answer/1837760394">知乎</a><spanclass="citation" data-cites="熊福端">@熊福端</span></p><h2 id="实现方法">实现方法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">code</span> <span class="attr">mkd</span>&gt;</span></span><br><span class="line">## 在 HTML 中使用 markdown</span><br><span class="line"></span><br><span class="line">在这里面写就行。</span><br><span class="line"><span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br><span class="line">code 块外面只能写 html 语法，比如</span><br><span class="line">## 这几个字就不会转成标题格式</span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span> <span class="attr">mkd</span>&gt;</span></span><br><span class="line">## 注意</span><br><span class="line"></span><br><span class="line">你可以多复制几个 code 块或 pre 块来实现多个 markdown 区域。</span><br><span class="line"></span><br><span class="line">用 markdown 语法插个图 ![](https://www.zhihu.com/favicon.ico)</span><br><span class="line"></span><br><span class="line">只需要引入一个 JS 即可，但是使用的是 3.0 的版本。</span><br><span class="line"><span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;marked.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 下载地址：https://cdn.jsdelivr.net/npm/marked@3.0.0/marked.min.js --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 懒得下载也可以直接用下面这段代码（但是不保证游客能访问） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/marked@3.0.0/marked.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"> <span class="comment">// 21年那时代码写得比较烂，献丑了，现在重写一版</span></span></span><br><span class="line"><span class="language-javascript"><span class="keyword">var</span> m = <span class="variable language_">document</span>.<span class="title function_">querySelectorAll</span>(<span class="string">&#x27;code[mkd=&quot;&quot;], pre[mkd=&quot;&quot;]&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; m.<span class="property">length</span>; i++)&#123;</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> e = m[i];</span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">var</span> div = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;div&#x27;</span>);</span></span><br><span class="line"><span class="language-javascript">  div.<span class="property">className</span> = <span class="string">&#x27;mkd&#x27;</span>;</span></span><br><span class="line"><span class="language-javascript">  div.<span class="property">innerHTML</span> = <span class="title function_">marked</span>(e.<span class="property">innerHTML</span>.<span class="title function_">trim</span>());</span></span><br><span class="line"><span class="language-javascript">  e.<span class="property">parentNode</span>.<span class="title function_">insertBefore</span>(div, e);</span></span><br><span class="line"><span class="language-javascript">  e.<span class="title function_">setAttribute</span>(<span class="string">&#x27;mkd&#x27;</span>, <span class="number">1</span>); <span class="comment">// 此处用标记防止重复解析</span></span></span><br><span class="line"><span class="language-javascript">&#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="language-css"></span></span><br><span class="line"><span class="language-css"><span class="selector-tag">div</span><span class="selector-class">.mkd</span> + <span class="selector-tag">code</span><span class="selector-attr">[mkd]</span>, <span class="selector-tag">div</span><span class="selector-class">.mkd</span> + pre<span class="selector-attr">[mkd]</span>&#123;</span></span><br><span class="line"><span class="language-css">  <span class="attribute">display</span>: none;</span></span><br><span class="line"><span class="language-css">&#125;</span></span><br><span class="line"><span class="language-css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="效果展示">效果展示</h2><body><p><code mkd> ## 在 HTML 中使用 markdown</p>在这里面写就行。 </code> code 块外面只能写 html 语法，比如 ##这几个字就不会转成标题格式<pre mkd>## 注意你可以多复制几个 code 块或 pre 块来实现多个 markdown 区域。用 markdown 语法插个图 ![](https://www.zhihu.com/favicon.ico)只需要引入一个 JS 即可，但是使用的是 3.0 的版本。</pre><script src="marked.min.js"></script><!-- 下载地址：https://cdn.jsdelivr.net/npm/marked@3.0.0/marked.min.js --><!-- 懒得下载也可以直接用下面这段代码（但是不保证游客能访问） --><script src="https://cdn.jsdelivr.net/npm/marked@3.0.0/marked.min.js"></script><script> // 21年那时代码写得比较烂，献丑了，现在重写一版var m = document.querySelectorAll('code[mkd=""], pre[mkd=""]');for(var i = 0; i < m.length; i++){  var e = m[i];  var div = document.createElement('div');  div.className = 'mkd';  div.innerHTML = marked(e.innerHTML.trim());  e.parentNode.insertBefore(div, e);  e.setAttribute('mkd', 1); // 此处用标记防止重复解析}</script><style>div.mkd + code[mkd], div.mkd + pre[mkd]{  display: none;}</style></body>]]></content>
      
      
      
        <tags>
            
            <tag> html </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安全防护</title>
      <link href="/2025/09/05/Linux%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4/"/>
      <url>/2025/09/05/Linux%E5%AE%89%E5%85%A8%E9%98%B2%E6%8A%A4/</url>
      
        <content type="html"><![CDATA[<body><p>本文基本转载于参考文献。</p><p><my-h1>一级标题</my-h1> <my-h2>二级标题</my-h2><my-h2>二级标题</my-h2> <my-h1>一级标题</my-h1> <my-h2>二级标题</my-h2><my-h2>二级标题</my-h2---------------------------------------------<my-h1>一级标题</my-h1> <my-h2>二级标题</my-h2> <my-h2>二级标题</my-h2><my-h1>一级标题</my-h1> <my-h2>二级标题</my-h2></p><p><my-h2>二级标题</my-h2></p><p><my-h1>基本分析</my-h1> 登录服务器的四要素: 【IP地址】+【端口】+【用户名】+【密码】 其中公网 IP地址全网公开，对于随机访问没有操作空间。如果怕被别有用心的人针对，也只能尽可能不要外泄你和网站的联系，只要你公开域名就一定会得到IP。</p><p>基于上述分析，我们能做的只有对【端口】、【用户名】及【密码】这三要素进行加强，来降低被攻破的风险：- 【端口】：将 SSH 远程登录端口修改为【非 22 端口】 -【用户名】：建立【非 root】的新用户、并禁用 root 用户 SSH 远程登录 -【密码】：SSH 启用 RSA 密钥验证登录、同时禁用密码验证登录记得按顺序来，别把自己锁在门外了。</p><p><my-h1>参考文献</my-h1>https://xtls.github.io/document/level-0/ch04-security.html</p><script src="https://cdn.jsdelivr.net/npm/marked@3.0.0/marked.min.js"></script><script>customTag('my-h1', myh1Handle);var m = document.querySelectorAll('code[mkd=""], pre[mkd=""]');for(var i = 0; i < m.length; i++){  var e = m[i];  var div = document.createElement('div');  div.className = 'mkd';  div.innerHTML = marked(e.innerHTML.trim());  e.parentNode.insertBefore(div, e);  e.setAttribute('mkd', 1); // 此处用标记防止重复解析}</script><style><!--markdown in html--> div.mkd + code[mkd], div.mkd + pre[mkd]{  display: none;}<!--列表样式--> my-h1 {  display: block;  font-size: 36px;  counter-increment: counter_myh1;}my-h2 {    display: block;    font-size: 24px;    counter-increment: counter_myh2;    counter-reset: counter_myh3;}my-h1::before {  content: counter(counter_myh1) ' ';  }my-h2::before {  content: counter(counter_myh1) '.' counter(counter_myh2) ' ';}</style></body>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WSL常见指令</title>
      <link href="/2025/09/04/WSL/"/>
      <url>/2025/09/04/WSL/</url>
      
        <content type="html"><![CDATA[<h2 id="安装-linux-发行版">1. 安装 Linux 发行版</h2><h3 id="官方发行版">1.1 官方发行版</h3><p>列出可用发行版 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --list --online</span><br></pre></td></tr></table></figure></p><p>安装指定发行版 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wsl --install [Distro]</span><br></pre></td></tr></table></figure></p><h3 id="任意发行版">1.2 任意发行版</h3><p>WSL 可以使用 tar 文件导入任意 Linux 发行版。</p><h4 id="获取-tar-文件">1.2.1 获取 tar 文件</h4><p>自行获取要导入的 tar 文件, 本例使用从容器中导出的方法。(CentOS可从官网直接下载)</p><h4 id="导入-tar">1.2.2 导入 tar</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl --import &lt;Distro&gt; &lt;InstallLocation&gt; &lt;FileName&gt;</span><br><span class="line"><span class="comment"># 示例: wsl --import DevLinux ./DevLinux ./Ubuntu-24.04-Base</span></span><br></pre></td></tr></table></figure><p><Distro>: 安装后该系统名称 <InstallLocation>: 要安装到的位置<FileName>: tar文件位置</p><h2 id="退出关闭-wsl">2. 退出/关闭 WSL</h2><p>快捷键 ctrl + d 注销当前用户。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 停止指定发行版</span></span><br><span class="line">wsl --terminate &lt;Distribution Name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 关闭 WSL, 停止所有发行版</span></span><br><span class="line">wsl --shutdown</span><br></pre></td></tr></table></figure></p><h2 id="常用指令">3. 常用指令</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在用户根目录启动(否则跟随当前目录)</span></span><br><span class="line">wsl ~                       </span><br><span class="line"><span class="comment"># 列出已安装的发行版</span></span><br><span class="line">wsl --list --verbose</span><br><span class="line"><span class="comment"># 设置默认发行版</span></span><br><span class="line">wsl --set-default &lt;Distro&gt;</span><br><span class="line"><span class="comment"># 启动指定发行版</span></span><br><span class="line">wsl -d &lt;Distro&gt;</span><br><span class="line"><span class="comment"># 以指定用户启动</span></span><br><span class="line">wsl -u &lt;UserName&gt;</span><br><span class="line"><span class="comment"># 注销或卸载 Linux 分发版</span></span><br><span class="line">wsl --unregister &lt;DistributionName&gt;</span><br></pre></td></tr></table></figure><h2 id="导出导入发行版">4. 导出/导入发行版</h2><p>导出后多次导入的方式可以重复安装多个相同版本的微软商店发行版。该方法也可以实现对发行版的命名。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wsl --<span class="built_in">export</span> &lt;Distribution Name&gt; &lt;FileName&gt;</span><br><span class="line">wsl --import &lt;Distribution Name&gt; &lt;InstallLocation&gt; &lt;FileName&gt;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>不可见字符</title>
      <link href="/2025/09/02/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/"/>
      <url>/2025/09/02/%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<p>第一行为用作大小参考的空格</p><table><thead><tr class="header"><th>不可见字符</th></tr></thead><tbody><tr class="odd"><td>[ ]</td></tr><tr class="even"><td>[⠀]</td></tr><tr class="odd"><td>[　]</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 杂项 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 特殊字符 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贝叶斯滤波器系列(5) - 一维卡尔曼滤波</title>
      <link href="/2025/09/01/BF05/"/>
      <url>/2025/09/01/BF05/</url>
      
        <content type="html"><![CDATA[<h1 id="kalman-filter">Kalman Filter</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %matplotlib widget</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> MyFilter.FilterPerformance <span class="keyword">as</span> FP</span><br><span class="line"><span class="keyword">import</span> MyFilter.UserLib <span class="keyword">as</span> UserLib</span><br><span class="line"><span class="keyword">import</span> MyFilter.BayesFilter <span class="keyword">as</span> BayesFilter</span><br><span class="line"></span><br><span class="line">figsize=(<span class="number">25</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h2 id="引言">1 引言</h2><p>The game is on.</p><p>最开始的时候，我们直接使用上一时刻的信息作为本时刻的先验信息(MA);再后来我们将上一时刻的信息通过模型预测出本时刻的信息，进而使用预测与测量的残差来对模型进行更新。总之，我们使用各种各样的的方法来尽可能提取测量的全部信息。<br />但这里其实有个问题，在预测/观测时获得的信息我们都认为其是一个一般变量，而非随机变量。这种方法其实丢掉了一些信息(方差)，而卡尔曼滤波器则将这些信息考虑了进来。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 采样参数</span></span><br><span class="line">SampleFre = <span class="number">10</span></span><br><span class="line">TotalTime = <span class="number">10</span>          <span class="comment"># 采样时间 不推荐大于10, 增加点数请增大采样率</span></span><br><span class="line">Step = <span class="number">1</span>/SampleFre</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型参数</span></span><br><span class="line">Model_accel = <span class="number">3</span></span><br><span class="line">Model_initialSpeed = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 仿真 ###</span></span><br><span class="line">ModelValue, ActualValue, MeasureValue = UserLib.Model.Generative(Step, TotalTime, <span class="keyword">lambda</span> x: Model_accel * x + Model_initialSpeed)</span><br></pre></td></tr></table></figure><h2 id="随机模型">随机模型</h2><h3 id="预测模型">预测模型</h3><p>在 g-h filter 中我们所使用的模型为</p><blockquote><p><span class="math display">$$\begin{align}   \nonumber    v_{n+1} &amp;= v_{n} + \Delta t \dot{v}_{n} \\   \nonumber    \dot{v}_{n} &amp;= \dot{v}_{n}\end{align}$$</span></p></blockquote><p>但我们在第一节的内容中就已经知道了，由于多种因素的影响，其加速度的噪声分布w (white)是标准正态分布 <spanclass="math inline"><em>ϕ</em> ∼ <em>N</em>(0,1)</span> 的 <spanclass="math inline"><em>γ</em></span> 倍。所以更准确的写法应该是</p><p><span class="math display">$$\begin{align}\nonumber \because w &amp;= \gamma \phi \sim N(0, \gamma^2) \quad\mathtt{and} \quad  \dot{v}_{0} = a \quad\quad\\  \nonumber  \\\nonumber   \therefore \dot{v}_{1,0} &amp;= \dot{v}_{0,0} + w \simN(a,\gamma^2)\\\nonumber    \dot{v}_{2,1} &amp;= \dot{v}_{1,1} + w \sim N(2a,2\gamma^2)\\\nonumber    &amp;\ \ \vdots\\\nonumber    \dot{v}_{n+1,n} &amp;= \dot{v}_{n,n} + w \sim N((n+1)a,(n+1)\gamma^2)\end{align}$$</span></p><blockquote><p>式中符号 <spanclass="math inline"><em>v̇</em><sub><em>n</em> + 1, <em>n</em></sub></span>表示在 <span class="math inline"><em>n</em></span> 时刻对 <spanclass="math inline"><em>n</em> + 1</span> 时刻速度导数的估计。</p></blockquote><p>很直观对吧，因为我们只对结果进行预测，但模型的不精确(既包括建模时的不精确又包含过程噪声)必然会使预测结果准确性下降。随着时间推移，这种不确定性越来越大，最终使预测结果彻底发散。</p><p>将上述过程的递推式写出 <span class="math display">$$\begin{align}    &amp;\left\{ \begin{matrix}        \begin{aligned}            \nonumber    \hat{\dot{v}}_{n+1, n} &amp;= \hat{\dot{v}}_{n,n}\\              \nonumber    {^a} \sigma^2_{n+1, n} &amp;= {^a} \sigma^2_{n,n} + \gamma^2        \end{aligned}    \end{matrix} \right.    \\    &amp;\left\{ \begin{matrix}        \begin{aligned}            \nonumber    \hat{v}_{n+1, n} &amp;= \hat{v}_{n, n} + \Deltat \hat{\dot{v}}_{n,n}\\              \nonumber    {^v} \sigma^2_{n+1, n} &amp;= {^v} \sigma^2_{n,n} + \Delta t^2  ({^a} \sigma^2_{n, n})^2        \end{aligned}    \end{matrix} \right.\end{align}$$</span></p><blockquote><p>式中符号 <spanclass="math inline"><sup><em>a</em></sup><em>σ</em><sub><em>n</em> + 1, <em>n</em></sub><sup>2</sup></span>表示在 <span class="math inline"><em>n</em></span> 时刻对 <spanclass="math inline"><em>n</em> + 1</span> 时刻的加速度方差的估计。</p></blockquote><h3 id="更新模型">更新模型</h3><p>刚刚已经分析过了，预测是不准确的，最终会使导致系统状态的发散。所以需要观测，观测使新息进入系统，从而使系统的方差减小，保持收敛。<br />对观测建模如下 <spanclass="math display"><em>z</em><sub><em>n</em></sub> = <em>h</em><em>x</em><sub><em>n</em></sub> + <em>r</em></span></p><blockquote><p>这里是较一般的写法，<spanclass="math inline"><em>h</em></span>是系数，<spanclass="math inline"><em>r</em></span>是某种高斯噪声。(比如，通过观测采样电阻(<spanclass="math inline"><em>h</em></span>)的电压(<spanclass="math inline"><em>z</em></span>)得到电流(<spanclass="math inline"><em>x</em></span>))</p></blockquote><p>这样就得到了观测的模型。现在我们是将两个不同参数的正态分布结合在一起，那怎样结合呢？<span class="math display">$$\begin{align}    \nonumber &amp;\because \mathtt{estimate} = (1 - \alpha_n) \cdot\mathtt{prediction} + \alpha_n \cdot \mathtt{measurement}\\    \nonumber &amp;\therefore \left\{ \begin{matrix}        \begin{aligned}            \nonumber   \hat{v}_{n,n} &amp;= (1 - \alpha_n) \cdot\hat{v}_{n,n-1} + \alpha_n \cdot z_n\\            \nonumber   {^v} \sigma^2_{n, n} &amp;= (1 - \alpha_n)^2\cdot {^v} \sigma^2_{n, n-1} + \alpha_n^2 \cdot {^r} \sigma^2_{n}        \end{aligned}    \end{matrix} \right.\end{align}$$</span></p><p>我们的目的是得到最优的估计值，也就是找到使方差最小的参数 <spanclass="math inline"><em>α</em><sub><em>n</em></sub></span>，所以有<br /><span class="math display">$$    \frac{d\ {^v} \sigma^2_{n, n}}{d\alpha_n} = 2\alpha_n \cdot {^r}\sigma^2_{n} - 2(1-\alpha_n) \cdot {^v} \sigma^2_{n,n-1} = 0$$</span> 解得 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\alpha_n = \frac&#123;&#123;^v&#125; \sigma^2_&#123;n,n-1&#125;&#125;&#123;&#123;^v&#125; \sigma^2_&#123;n,n-1&#125; + &#123;^r&#125; \sigma^2_&#123;n&#125;&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure> 将结果带回，解出最优估计的方差 <spanclass="math display"><sup><em>v</em></sup><em>σ</em><sub><em>n</em>, <em>n</em></sub><sup>2</sup> = (1−<em>α</em><sub><em>n</em></sub>) ⋅ <sup><em>v</em></sup><em>σ</em><sub><em>n</em>, <em>n</em> − 1</sub><sup>2</sup></span></p><p>至此，我们就已经完全推导出了一维卡尔曼滤波器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KalmanFilter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x0, xdot, w, r</span>):</span><br><span class="line">        <span class="variable language_">self</span>.estimate = x0</span><br><span class="line">        <span class="variable language_">self</span>.dot = xdot</span><br><span class="line">        <span class="variable language_">self</span>.px = <span class="number">0.5</span></span><br><span class="line">        <span class="variable language_">self</span>.pxdot = <span class="number">0.5</span></span><br><span class="line">        <span class="variable language_">self</span>.w = w</span><br><span class="line">        <span class="variable language_">self</span>.r = r</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, measurement, dt</span>):</span><br><span class="line">        <span class="comment"># 预测步</span></span><br><span class="line">        <span class="variable language_">self</span>.estimate = <span class="variable language_">self</span>.estimate + <span class="variable language_">self</span>.dot * dt</span><br><span class="line">        <span class="variable language_">self</span>.dot = <span class="variable language_">self</span>.dot</span><br><span class="line"></span><br><span class="line">        <span class="variable language_">self</span>.px = <span class="variable language_">self</span>.px + <span class="variable language_">self</span>.pxdot * dt * dt</span><br><span class="line">        <span class="variable language_">self</span>.pxdot = <span class="variable language_">self</span>.pxdot + <span class="variable language_">self</span>.w</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新步</span></span><br><span class="line">        <span class="variable language_">self</span>.k = <span class="variable language_">self</span>.px / (<span class="variable language_">self</span>.px + <span class="variable language_">self</span>.r)</span><br><span class="line">        <span class="variable language_">self</span>.estimate = <span class="variable language_">self</span>.estimate + <span class="variable language_">self</span>.k * (measurement - <span class="variable language_">self</span>.estimate)</span><br><span class="line">        <span class="variable language_">self</span>.px = (<span class="number">1</span> - <span class="variable language_">self</span>.k) * <span class="variable language_">self</span>.px</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新估计</span></span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.estimate</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">refilter</span>(<span class="params">self, Measurement_sequence, dt</span>):</span><br><span class="line">        filter_sequence = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Measurement_sequence)):</span><br><span class="line">            filter_sequence.append(<span class="variable language_">self</span>.update(Measurement_sequence[i], dt))</span><br><span class="line">        <span class="keyword">return</span> filter_sequence</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">filter</span> = KalmanFilter(Model_initialSpeed, Model_accel, <span class="number">0.2</span>, <span class="number">1</span>)</span><br><span class="line">FilterValue = <span class="built_in">filter</span>.refilter(MeasureValue, Step)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 绘图展示 ###</span></span><br><span class="line">plt.figure(figsize=(<span class="number">25</span>, <span class="number">5</span>))</span><br><span class="line">plt.plot(ModelValue, <span class="string">&#x27;.-&#x27;</span>, label=<span class="string">&quot;Model&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(ActualValue, <span class="string">&#x27;*-&#x27;</span>, label=<span class="string">&quot;Actual&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(MeasureValue, <span class="string">&#x27;-&#x27;</span> , label=<span class="string">&quot;Measure&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(FilterValue, <span class="string">&#x27;o-&#x27;</span>, label=<span class="string">&quot;Filter&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower right&#x27;</span>) <span class="comment">#绘制图例</span></span><br><span class="line"></span><br><span class="line">FP.FilterPerformance.analysis(FilterValue, MeasureValue, ActualValue)</span><br></pre></td></tr></table></figure><p><imgsrc="/images/2_3.1-D%20Kalman%20FIlter_files/2_3.1-D%20Kalman%20FIlter_7_0.png" /></p><p><imgsrc="/images/2_3.1-D%20Kalman%20FIlter_files/2_3.1-D%20Kalman%20FIlter_7_1.png" /></p><h2 id="总结">总结</h2><ol type="1"><li><p>初始化<br />初始化需要两个参数，初始状态和初始方差。初始化参数可以由其他的系统、过程或基于经验和理论知识所得出的合理的猜测来获得。即使初始化参数不太准确，卡尔曼滤波器也能收敛到真值。</p></li><li><p>循环</p></li></ol><ul><li>预测：利用上一周期的最优估计来计算出本周期的预测值。</li></ul><span class="math inline">   </span> 状态外插：<br />$$ {<p>.</p><span class="math display">$$$\qquad$ 协方差外插：  $$</span> {<p>. $$</p><ul><li>测量：利用本周期的测量来使模型收敛。<br /><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$\qquad$ 计算卡尔曼增益:  </span><br><span class="line">$$</span><br><span class="line">\alpha_n = \frac&#123;&#123;^v&#125; \sigma^2_&#123;n,n-1&#125;&#125;&#123;&#123;^v&#125; \sigma^2_&#123;n,n-1&#125; + &#123;^r&#125; \sigma^2_&#123;n&#125;&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure> <span class="math inline">   </span> 状态更新: <spanclass="math display"><em>v̂</em><sub><em>n</em>, <em>n</em></sub> = (1−<em>α</em><sub><em>n</em></sub>) ⋅ <em>v̂</em><sub><em>n</em>, <em>n</em> − 1</sub> + <em>α</em><sub><em>n</em></sub> ⋅ <em>z</em><sub><em>n</em></sub></span></li></ul><p><span class="math inline">   </span> 协方差更新: <spanclass="math display"><sup><em>v</em></sup><em>σ</em><sub><em>n</em>, <em>n</em></sub><sup>2</sup> = (1−<em>α</em><sub><em>n</em></sub>) ⋅ <sup><em>v</em></sup><em>σ</em><sub><em>n</em>, <em>n</em> − 1</sub><sup>2</sup></span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">bias0    = []</span><br><span class="line">bias1    = []</span><br><span class="line"></span><br><span class="line">search_Lowlimit = <span class="number">0</span></span><br><span class="line">search_Upplimit = <span class="number">2</span></span><br><span class="line">search_Size = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">x = np.outer(np.linspace(search_Lowlimit, search_Upplimit, search_Size), np.ones(search_Size))</span><br><span class="line">y = x.copy().T</span><br><span class="line">z = np.zeros((search_Size, search_Size))</span><br><span class="line">zmax = []</span><br><span class="line">zmaxindex = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(search_Lowlimit, search_Upplimit * search_Size, search_Upplimit):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(search_Lowlimit, search_Upplimit * search_Size, search_Upplimit):</span><br><span class="line">        <span class="built_in">filter</span> = KalmanFilter(Model_initialSpeed, Model_accel, i/search_Size, j/search_Size)</span><br><span class="line">        FilterValue = <span class="built_in">filter</span>.refilter(MeasureValue, Step)</span><br><span class="line">        bias0 = np.mean(<span class="built_in">abs</span>(np.array(MeasureValue) - np.array(ActualValue)))</span><br><span class="line">        bias1 = np.mean(<span class="built_in">abs</span>(np.array(FilterValue) - np.array(ActualValue)))</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> - (bias1 / bias0)) &lt; <span class="number">0</span>:</span><br><span class="line">            z[<span class="built_in">int</span>(i/search_Size)][<span class="built_in">int</span>(j/search_Size)] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            z[<span class="built_in">int</span>(i/search_Upplimit)][<span class="built_in">int</span>(j/search_Upplimit)] = (<span class="number">1</span> - (bias1 / bias0))</span><br><span class="line">        zmax.append(z.<span class="built_in">max</span>())</span><br><span class="line">        zmaxindex.append([i, j])</span><br><span class="line"></span><br><span class="line">a = np.array(zmaxindex[zmax.index(<span class="built_in">max</span>(zmax))])</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">20</span>, <span class="number">10</span>))</span><br><span class="line">contours = plt.contourf(x, y, z, <span class="number">100</span>, cmap=<span class="string">&#x27;jet&#x27;</span>)</span><br><span class="line">plt.clabel(contours, inline=<span class="literal">True</span>, fontsize=<span class="number">8</span>)</span><br><span class="line">plt.colorbar()</span><br><span class="line">plt.suptitle(<span class="string">f&#x27;Max average deviation reduction ratio:<span class="subst">&#123;np.array(zmax).<span class="built_in">max</span>()*<span class="number">100</span>:<span class="number">.3</span>f&#125;</span>% at <span class="subst">&#123;a/search_Size&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">20</span>, <span class="number">10</span>))</span><br><span class="line">ax = plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">ax.plot_surface(x, y, z, alpha=<span class="number">0.6</span>, cmap=<span class="string">&#x27;jet&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;max average deviation reduction ratio&#x27;</span>)</span><br><span class="line">ax.set_zlim(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">ax.contour(x, y, z, [i/<span class="number">100</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">int</span>(np.array(zmax).<span class="built_in">max</span>()*<span class="number">100</span>), <span class="number">1</span>)], cmap=<span class="string">&#x27;jet&#x27;</span>)</span><br></pre></td></tr></table></figure><p><imgsrc="/images/2_3.1-D%20Kalman%20FIlter_files/2_3.1-D%20Kalman%20FIlter_9_1.png" /></p><p><imgsrc="/images/2_3.1-D%20Kalman%20FIlter_files/2_3.1-D%20Kalman%20FIlter_9_2.png" /></p>]]></content>
      
      
      <categories>
          
          <category> 贝叶斯滤波器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滤波器 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贝叶斯滤波器系列(4) - G-H 滤波器</title>
      <link href="/2025/09/01/BF04/"/>
      <url>/2025/09/01/BF04/</url>
      
        <content type="html"><![CDATA[<h1 id="g-h-滤波器">g-h 滤波器</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %matplotlib widget</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> MyFilter.FilterPerformance <span class="keyword">as</span> FP</span><br><span class="line"><span class="keyword">import</span> MyFilter.UserLib <span class="keyword">as</span> UserLib</span><br><span class="line"></span><br><span class="line">figsize=(<span class="number">25</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h2 id="引言">1 引言</h2><p>有了贝叶斯思想后我们再回头来看之前使用的滤波器 - <strong>CAFilter</strong>:<br /><span class="math display">$$\hat{x} = \frac{n-1}{n} \hat{x}_{last}+ \frac{1}{n}x_n$$</span> <span class="math inline">   </span> <spanclass="math inline"><em>x̂</em><sub><em>l</em><em>a</em><em>s</em><em>t</em></sub></span>就是我们的先验信息，且随着次数增加，我们越来越相信先验信息(权重在极限情况下为1 ); 新的测量值为 <spanclass="math inline"><em>x</em><sub><em>n</em></sub></span> ,每次观测的新息越来越少，我们对观测的信任程度逐渐下降(权重在极限情况下为0 )。</p><ul><li><strong>SMA Filter</strong>: <span class="math display">$$\hat{x} = \hat{x}_{last} + \frac{1}{n} \cdot (x_M - x_{M-n})$$</span></li></ul><p><span class="math inline">   </span> 在 SMA中，先验信息依旧是之前测量平均值。但每次都不再信任队列中最末端的数据，并将新数据加入队列中。</p><ul><li><strong>WMA Filter</strong>:</li></ul><p><span class="math inline">   </span> WMA 与 SMA相类似，只不过其更相信较新的数据。(其实 WMA 是个双层的 SMA ,权重是一个杨辉三角)</p><ul><li><p><strong>EMA Filte</strong>r: <spanclass="math display">lim<sub><em>n</em> → ∞</sub><em>x̂</em><sub><em>n</em> + 1</sub> = (1−<em>α</em>) ⋅ <em>x̂</em><sub><em>n</em></sub> + <em>α</em> ⋅ <em>x</em><sub><em>n</em> + 1</sub></span><span class="math inline">   </span> EMA对于先验新息的信任程度是一个固定的常数 (1-), 并对新息给予以恒定的信任度。(无偏估计嘛，信任度必须是互补的)</p></li><li><p><strong>DEMA Filter</strong>:</p></li></ul><p><span class="math inline">   </span>这个不会，他妈的到底为什么线性模型的 y 截距是 <spanclass="math inline">$(2\hat{x} - \hat{\hat{x}})$</span> 啊？？？特意去翻了 1961年布朗平滑的论文，原作者直接注意到，行我瞎，我注意力涣散，算你牛逼🤡。线性模型的效果也太好了…回学校拿草纸算一下再说吧。</p><ul><li><strong>Adam Filter</strong>:</li></ul><p><span class="math inline">   </span> Adam则是利用指数滤波平滑预测数据的一阶矩(<spanclass="math inline"><em>E</em><em>X</em></span>)与二阶矩(<spanclass="math inline"><em>D</em><em>X</em></span>)，使用平滑后的矩作为先验信息进行回归分析计算出本次的预测值；再使用观测值的残差对矩进行更新并利用梯度下降对预测值进行矫正。</p><p>其实即使频域性能好的滤波器 (FIR、IIR) 也可以用这种思想来看待(从数电的角度看的话：（抑制噪声=&gt;抑制高频成分=&gt;单一点不可能有频率信息=&gt;保存之前的点）得，从组合逻辑变成时序逻辑了，而寄存器存储的就是先验信息)。但是不同的是大多数信号处理的教材都是面向电子信息工程的学生，这些人更在意如何在上帝视角去更好的处理整个信号(在意频域性能，比如如何处理一首歌曲的音频信息)；但我们却很在意实时性(时域性能，总不能让传感器先运行一遍记录好信号再来处理吧？新概念刻舟求剑？)。在性能选择上的分歧，致使我们几乎不会同时选用两类滤波器。<del>(你问我为啥同时学，答曰：我是电气工程的，姥姥(电信)不亲舅舅(自动化)不爱，自己学完才知道技能树点歪了🤕)</del></p><p>从本节开始，我们将会将系统模型引入滤波器，从而进一步提升滤波器性能。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 采样参数</span></span><br><span class="line">SampleFre = <span class="number">10</span></span><br><span class="line">TotalTime = <span class="number">10</span>          <span class="comment"># 采样时间 不推荐大于10, 增加点数请增大采样率</span></span><br><span class="line">Step = <span class="number">1</span>/SampleFre</span><br><span class="line"></span><br><span class="line"><span class="comment"># 模型参数</span></span><br><span class="line">Model_accel = <span class="number">2</span></span><br><span class="line">Model_initialSpeed = <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 仿真 ###</span></span><br><span class="line">ModelValue, ActualValue, MeasureValue = UserLib.Model.Generative(Step, TotalTime, <span class="keyword">lambda</span> x: Model_accel * x + Model_initialSpeed)</span><br></pre></td></tr></table></figure><h2 id="系统建模">2 系统建模</h2><h2 id="仿真建模">2.1 仿真建模</h2><p>我们依然采用匀速运动模型，只不过这次使用 lambda表达式将模型传入封装好的生成函数。现在来好好看看我们的仿真模型都有什么吧。&gt; <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lambda</span> x: Model_accel * x + Model_initialSpeed</span><br></pre></td></tr></table></figure></p><p>由微分学基本常识可知，当 <spanclass="math inline"><em>d</em><em>t</em> → 0</span> 时, 若函数可微则<span class="math inline"><em>d</em><em>y</em></span>为线性主部。这告诉我们，只要采样率够高，一切模型都是线性的<del>力大砖飞</del>。但是现实情况不可能是完美的线性模型，所以这里用泰勒多项式的二阶、三阶项<spanclass="math inline">(0.0317*<em>x</em>**2) − (0.00223*<em>x</em>**3)</span>,来模拟模型的非线性。而项 <spanclass="math inline">(0.312*(<em>n</em><em>p</em>.<em>s</em><em>i</em><em>n</em>(<em>n</em><em>p</em>.<em>p</em><em>i</em>*<em>x</em>)+<em>n</em><em>p</em>.<em>s</em><em>i</em><em>n</em>(6*<em>n</em><em>p</em>.<em>p</em><em>i</em>*<em>x</em>)+<em>n</em><em>p</em>.<em>s</em><em>i</em><em>n</em>(12*<em>n</em><em>p</em>.<em>p</em><em>i</em>*<em>x</em>)))</span>则模拟某种外因导致的系统固有震荡，比如说小车轴承安装不共轴之类的。 &gt;<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">temp += (<span class="number">0.0317</span> * x**<span class="number">2</span>) - (<span class="number">0.00223</span> * x**<span class="number">3</span>) </span><br><span class="line">     + (<span class="number">0.312</span> * (np.sin(np.pi*x) + np.sin(<span class="number">6</span>*np.pi*x) + np.sin(<span class="number">12</span>*np.pi*x)))</span><br></pre></td></tr></table></figure></p><p>当在时间中段，给予一个阶跃信号，模拟突然刹车或撞击产生的瞬间变化。</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> x &gt; totalTime/<span class="number">2</span>:</span><br><span class="line">    temp -= model_func(totalTime/<span class="number">3</span>)</span><br></pre></td></tr></table></figure></blockquote><p>最后再使用 <span class="math inline"><em>N</em>(0，0.2)</span>来表征过程噪声，比如地面的崎岖；和标准正态分布 <spanclass="math inline"><em>N</em>(0，1)</span> 来表征测量噪声。</p><h2 id="预测建模">2.2 预测建模</h2><p>使用简单的运动学方程来写出时刻 n 到 n+1递推关系式。(这里也推荐将导数符号从 <spanclass="math inline"><em>v</em>′</span> 改成 <spanclass="math inline"><em>v̇</em></span>,为啥？真幸运，看来你还没见过写四个角标的符号，到时候就知道为啥要把导数符号放到头顶里了😭)<span class="math display">$$\begin{align}   \nonumber    v_{n+1} &amp;= v_{n} + \Delta t \dot{v}_{n} \\   \nonumber    \dot{v}_{n} &amp;= \dot{v}_{n}\end{align}$$</span></p><p>让我们写的更简洁一点</p><p><span class="math display">$$    \begin{bmatrix}    {v}_{n+1} \\ \dot{v}_{n+1}      \end{bmatrix}    =    \begin{bmatrix}    1 &amp; \Delta t\\    0 &amp; 1    \end{bmatrix}    \begin{bmatrix}    {v}_{n} \\ \dot{v}_{n}      \end{bmatrix}$$</span></p><p>其中向量 <span class="math inline">$\begin{bmatrix} {v}_{n} \\\dot{v}_{n} \end{bmatrix}$</span>是我们对被控对象(plant)所感兴趣的物理量, 称之为状态变量(state)。</p><p>好，现在我们就可以根据上一时刻的系统状态从而猜出本时刻系统的状态了(先验信息)。然后像之前的那些滤波器一样，通过某种比例来将先验信息与后验信息(测量值)结合在一起。·</p><p><spanclass="math display"><em>e</em><em>s</em><em>t</em><em>i</em><em>m</em><em>a</em><em>t</em><em>e</em> = (1−<em>α</em>) ⋅ <em>p</em><em>r</em><em>e</em><em>d</em><em>i</em><em>c</em><em>t</em><em>i</em><em>o</em><em>n</em> + <em>α</em> ⋅ <em>m</em><em>e</em><em>a</em><em>s</em><em>u</em><em>r</em><em>e</em><em>m</em><em>e</em><em>n</em><em>t</em></span></p><p>根据刚刚的思路实现滤波器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TestFilter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, alpha, dot, init</span>):</span><br><span class="line">        <span class="variable language_">self</span>.alpha = alpha</span><br><span class="line">        <span class="variable language_">self</span>.dot = dot</span><br><span class="line">        <span class="variable language_">self</span>.estimate = init</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, measurement, dt</span>):</span><br><span class="line">        <span class="comment"># 预测步</span></span><br><span class="line">        prediction = <span class="variable language_">self</span>.estimate + <span class="variable language_">self</span>.dot * dt</span><br><span class="line">        <span class="variable language_">self</span>.dot = <span class="variable language_">self</span>.dot</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 数据融合(贝叶斯)</span></span><br><span class="line">        <span class="variable language_">self</span>.estimate = (<span class="number">1</span> - <span class="variable language_">self</span>.alpha) * prediction + <span class="variable language_">self</span>.alpha * measurement</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.estimate</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">refilter</span>(<span class="params">self, Measurement_sequence, dt</span>):</span><br><span class="line">        filter_sequence = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Measurement_sequence)):</span><br><span class="line">            filter_sequence.append(<span class="variable language_">self</span>.update(Measurement_sequence[i], dt))</span><br><span class="line">        <span class="keyword">return</span> filter_sequence</span><br></pre></td></tr></table></figure><p>漂亮，赶紧来试试效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">filter</span> = TestFilter(<span class="number">0.5</span>, Model_accel, Model_initialSpeed)</span><br><span class="line">FilterValue = <span class="built_in">filter</span>.refilter(MeasureValue, Step)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 绘图展示 ###</span></span><br><span class="line">plt.figure(figsize=(<span class="number">25</span>, <span class="number">5</span>))</span><br><span class="line">plt.plot(ModelValue, <span class="string">&#x27;.-&#x27;</span>, label=<span class="string">&quot;Model&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(ActualValue, <span class="string">&#x27;*-&#x27;</span>, label=<span class="string">&quot;Actual&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(MeasureValue, <span class="string">&#x27;-&#x27;</span>, label=<span class="string">&quot;Measure&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(FilterValue, <span class="string">&#x27;o-&#x27;</span>, label=<span class="string">&quot;Filter&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower right&#x27;</span>) <span class="comment">#绘制图例</span></span><br><span class="line"></span><br><span class="line">FP.FilterPerformance.analysis(FilterValue, MeasureValue, ActualValue)</span><br></pre></td></tr></table></figure><p><imgsrc="/images/2_2.g-h%20Filter_files/2_2.g-h%20Filter_8_0.png" /></p><p><imgsrc="/images/2_2.g-h%20Filter_files/2_2.g-h%20Filter_8_1.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">bias0    = []</span><br><span class="line">bias1    = []</span><br><span class="line">redratio = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>):</span><br><span class="line">    <span class="built_in">filter</span> = TestFilter(i/<span class="number">100</span>, Model_accel, Model_initialSpeed)</span><br><span class="line">    FilterValue = <span class="built_in">filter</span>.refilter(MeasureValue, Step)</span><br><span class="line">    bias0.append(np.mean(<span class="built_in">abs</span>(np.array(MeasureValue) - np.array(ActualValue))))</span><br><span class="line">    bias1.append(np.mean(<span class="built_in">abs</span>(np.array(FilterValue) - np.array(ActualValue))))</span><br><span class="line">    redratio.append(<span class="number">1</span> - bias1[-<span class="number">1</span>] / bias0[-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=figsize)</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">ax.plot([i/<span class="number">100</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, bias1.__len__() + <span class="number">1</span>, <span class="number">1</span>)], bias1, <span class="string">&#x27;-o&#x27;</span>, label=<span class="string">&quot;Mean abs bias&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">ax.legend(loc=<span class="string">&#x27;lower left&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax2 = ax.twinx()</span><br><span class="line">ax2.plot([i/<span class="number">100</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, redratio.__len__() + <span class="number">1</span>, <span class="number">1</span>)],redratio, <span class="string">&#x27;-ob&#x27;</span>, label=<span class="string">&quot;Reduction ratio&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">ax2.legend(loc=<span class="string">&#x27;lower right&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.suptitle(<span class="string">f&#x27;Max average deviation reduction ratio:<span class="subst">&#123;np.array(redratio).<span class="built_in">max</span>()*<span class="number">100</span>:<span class="number">.3</span>f&#125;</span>% at <span class="subst">&#123;(np.array(redratio).argmax() + <span class="number">1</span>)/<span class="number">100</span>&#125;</span>&#x27;</span>)</span><br><span class="line">plt.plot(np.array(redratio).argmax()/<span class="number">100</span> , np.array(redratio).<span class="built_in">max</span>(), <span class="string">&#x27;*g&#x27;</span>, markersize=<span class="number">10</span>)</span><br><span class="line">plt.axhline(np.array(redratio).<span class="built_in">max</span>(), color=<span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure><p><imgsrc="/images/2_2.g-h%20Filter_files/2_2.g-h%20Filter_9_1.png" /></p><p>效果相当不错对吧!但是从误差分段图中可以发现,滤波器对突变的响应很类似于 EMA 的响应;又或者当模型不准确时(比如斜率取相反数，ɑ取0.1)，滤波器有非常大的滞后性。<br />这肯定是我们不想见到的，比如说我们的小车速度闭环控制系统已经让发动机以最大功率开始工作了，刚开始非常符合我们的加速度的期待，但随着速度增大，空气阻力使加速度不断下降但发动机的功率无法继续提高(偏离了期望的模型),此时发生速度波动我们就无法高效的观测。<br />怎么办呢？</p><h2 id="更新模型">2.3 更新模型</h2><p>假如模型很完美的工作一段时间之后，由于某些影响模型不再准确了那么我们该怎么办呢？emmmm那就想办法更新模型呗。 (啥？你说更加相信测量值，想办法修改 <spanclass="math inline"><em>α</em></span>?跑偏了，麻溜回来。那叫卡尔曼滤波器，是下节的内容😋)<br />不妨把我们手上拥有的信息列出来: <spanclass="math inline"><em>v̂</em>, <em>v̇</em>, <em>d</em><em>t</em></span>再加上本次测量值 Z。如果从稳态进入暂态的话会有什么样子的特征呢？不妨看看上面的误差图。很显然突变发生时误差会有一个极大的尖峰。或者换一种说法，当我们的先验信息不再准确时，依赖模型的”惯性”会使预测值与测量值产生一个极大的误差。<br />更进一步的说，我们可以使用残差(我习惯将残差的绝对值称为误差)来对 <spanclass="math inline"><em>v̇</em></span> 进行某种更新。接下来看我表演<br /><span class="math display">$$\begin{align}    \nonumber       \mathtt{estimate} &amp;= (1 - \alpha) \cdot\mathtt{prediction} + \alpha \cdot \mathtt{measurement}\\                    \hat{v}_{n,n} &amp;= (1 - \alpha) \cdot\hat{v}_{n,n-1} + \alpha \cdot z_n\\    \nonumber       \hat{v}_{n,n} - \hat{v}_{n,n-1} &amp;= (1 - \alpha-1) \cdot \hat{v}_{n,n-1} + \alpha \cdot z_n\\    \nonumber       (\hat{v}_{n,n} - \hat{v}_{n-1,n-1})-(\hat{v}_{n,n-1} - \hat{v}_{n-1,n-1}) &amp;=  \alpha \cdot (z_n -\hat{v}_{n,n-1}) \\                    \hat{\dot{v}}_{n,n} - \hat{\dot{v}}_{n,n-1} &amp;=\alpha \cdot \frac {(z_n - \hat{v}_{n,n-1})}{dt} \\\end{align}$$</span> (1) 和 (2)即是我们的状态更新方差，推导过程中为了表示逻辑的连续性并没有更改参数符号。但是可以明显注意到这里的融合参数不应该选择相同的，因为我们传感器直接测量的是速度，融合速度时参数与传感器的精确度有关；而更新加速度时只与精密度有关。</p><blockquote><ul><li>正确度 (correctness of measurement):指测量结果与真值的偏离程度，表征了系统误差的大小。(数据是否有偏)<br /></li><li>精密度 (precision of measurement):测量读数重复一致的程度，表征了随机误差的大小。(数据散布情况)<br /></li><li>精确度 (accuracy of measurement):指测量结果与真值符合一致的程度，表征系统误差和随机误差的综合大小。<br /><p align="right">————《电气测量》第一章</p>所以让你们好好学课内知识嘛，思想远比得分更重要</li></ul></blockquote><p>整理一下，写出方程组</p><p><span class="math display">$$\left\{    \begin{matrix}        \begin{align}            \nonumber   \hat{v}_{n,n} &amp;= \hat{v}_{n,n-1} + \alpha\cdot (z_n - \hat{v}_{n,n-1})\\            \nonumber   \hat{\dot{v}}_{n,n} &amp;= \hat{\dot{v}}_{n,n-1}+ \beta \cdot \frac {(z_n - \hat{v}_{n,n-1})}{dt} \\        \end{align}    \end{matrix}\right.$$</span></p><p>现在可以写出完整版的 g-h 滤波器了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ghFilter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, alpha, beta, dot, init</span>):</span><br><span class="line">        <span class="variable language_">self</span>.alpha = alpha</span><br><span class="line">        <span class="variable language_">self</span>.beta = beta</span><br><span class="line">        <span class="variable language_">self</span>.dot = dot</span><br><span class="line">        <span class="variable language_">self</span>.estimate = init</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, measurement, dt</span>):</span><br><span class="line">        <span class="comment"># 预测步</span></span><br><span class="line">        prediction = <span class="variable language_">self</span>.estimate + <span class="variable language_">self</span>.dot * dt</span><br><span class="line">        <span class="variable language_">self</span>.dot = <span class="variable language_">self</span>.dot</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 更新步</span></span><br><span class="line">        residual = measurement - prediction</span><br><span class="line">        <span class="variable language_">self</span>.dot = <span class="variable language_">self</span>.dot + <span class="variable language_">self</span>.beta * (residual) / dt</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 数据融合(贝叶斯)</span></span><br><span class="line">        <span class="variable language_">self</span>.estimate = (<span class="number">1</span> - <span class="variable language_">self</span>.alpha) * prediction + <span class="variable language_">self</span>.alpha * measurement</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.estimate</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">refilter</span>(<span class="params">self, Measurement_sequence, dt</span>):</span><br><span class="line">        filter_sequence = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(Measurement_sequence)):</span><br><span class="line">            filter_sequence.append(<span class="variable language_">self</span>.update(Measurement_sequence[i], dt))</span><br><span class="line">        <span class="keyword">return</span> filter_sequence</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">filter</span> = ghFilter(<span class="number">0.478</span>, <span class="number">0.002</span>, Model_accel, Model_initialSpeed)</span><br><span class="line">FilterValue = <span class="built_in">filter</span>.refilter(MeasureValue, Step)</span><br><span class="line"></span><br><span class="line"><span class="comment">### 绘图展示 ###</span></span><br><span class="line">plt.figure(figsize=(<span class="number">25</span>, <span class="number">5</span>))</span><br><span class="line">plt.plot(ModelValue, <span class="string">&#x27;.-&#x27;</span>, label=<span class="string">&quot;Model&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(ActualValue, <span class="string">&#x27;*-&#x27;</span>, label=<span class="string">&quot;Actual&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(MeasureValue, <span class="string">&#x27;-&#x27;</span>, label=<span class="string">&quot;Measure&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(FilterValue, <span class="string">&#x27;o-&#x27;</span>, label=<span class="string">&quot;Filter&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower right&#x27;</span>) <span class="comment">#绘制图例</span></span><br><span class="line"></span><br><span class="line">FP.FilterPerformance.analysis(FilterValue, MeasureValue, ActualValue)</span><br></pre></td></tr></table></figure><p><imgsrc="/images/2_2.g-h%20Filter_files/2_2.g-h%20Filter_13_0.png" /></p><p><imgsrc="/images/2_2.g-h%20Filter_files/2_2.g-h%20Filter_13_1.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">bias0    = []</span><br><span class="line">bias1    = []</span><br><span class="line"></span><br><span class="line">searchSize = <span class="number">100</span></span><br><span class="line">x = np.outer(np.linspace(<span class="number">0</span>, <span class="number">1</span>, searchSize), np.ones(searchSize))</span><br><span class="line">y = x.copy().T</span><br><span class="line">z = np.zeros((searchSize, searchSize))</span><br><span class="line">zmax = []</span><br><span class="line">zmaxindex = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, searchSize, <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, searchSize, <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">filter</span> = ghFilter(i/searchSize, j/searchSize, Model_accel, Model_initialSpeed)</span><br><span class="line">        FilterValue = <span class="built_in">filter</span>.refilter(MeasureValue, Step)</span><br><span class="line">        bias0 = np.mean(<span class="built_in">abs</span>(np.array(MeasureValue) - np.array(ActualValue)))</span><br><span class="line">        bias1 = np.mean(<span class="built_in">abs</span>(np.array(FilterValue) - np.array(ActualValue)))</span><br><span class="line">        <span class="keyword">if</span> (<span class="number">1</span> - (bias1 / bias0)) &lt; <span class="number">0</span>:</span><br><span class="line">            z[i][j] = <span class="number">0</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            z[i][j] = (<span class="number">1</span> - (bias1 / bias0))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        zmax.append(z.<span class="built_in">max</span>())</span><br><span class="line">        zmaxindex.append([i, j])</span><br><span class="line"></span><br><span class="line">a = np.array(zmaxindex[zmax.index(<span class="built_in">max</span>(zmax))])</span><br><span class="line">z2 = np.zeros((searchSize, searchSize))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>((a[<span class="number">0</span>] - <span class="number">5</span>)*np.sqrt(searchSize)), <span class="built_in">int</span>((a[<span class="number">0</span>] + <span class="number">5</span>)*np.sqrt(searchSize)), <span class="number">1</span>):</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">int</span>((a[<span class="number">1</span>] - <span class="number">5</span>)*np.sqrt(searchSize)), <span class="built_in">int</span>((a[<span class="number">1</span>] + <span class="number">5</span>)*np.sqrt(searchSize)), <span class="number">1</span>):</span><br><span class="line">        <span class="built_in">filter</span> = ghFilter(i/searchSize ** <span class="number">1.5</span>, j/searchSize ** <span class="number">1.5</span>, Model_accel, Model_initialSpeed)</span><br><span class="line">        FilterValue = <span class="built_in">filter</span>.refilter(MeasureValue, Step)</span><br><span class="line">        bias0 = np.mean(<span class="built_in">abs</span>(np.array(MeasureValue) - np.array(ActualValue)))</span><br><span class="line">        bias1 = np.mean(<span class="built_in">abs</span>(np.array(FilterValue) - np.array(ActualValue)))</span><br><span class="line">        zmax.append(z2.<span class="built_in">max</span>())</span><br><span class="line">        zmaxindex.append([i, j])</span><br><span class="line">        </span><br><span class="line">a = np.array(zmaxindex[zmax.index(<span class="built_in">max</span>(zmax))])</span><br><span class="line"></span><br><span class="line">fig = plt.figure(figsize=(<span class="number">20</span>, <span class="number">10</span>))</span><br><span class="line">ax = plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">ax.plot_surface(x, y, z)</span><br><span class="line">ax.set_xlabel(<span class="string">&#x27;alpha&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;beta&#x27;</span>)</span><br><span class="line">ax.set_zlabel(<span class="string">&#x27;max average deviation reduction ratio&#x27;</span>)</span><br><span class="line">ax.set_zlim(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">plt.suptitle(<span class="string">f&#x27;Max average deviation reduction ratio:<span class="subst">&#123;np.array(zmax).<span class="built_in">max</span>()*<span class="number">100</span>:<span class="number">.3</span>f&#125;</span>% at <span class="subst">&#123;a/<span class="number">1000</span>&#125;</span>&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ax.contour(x, y, z, [i/<span class="number">100</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">int</span>(np.array(zmax).<span class="built_in">max</span>()*<span class="number">100</span>), <span class="number">1</span>)], cmap=<span class="string">&#x27;jet&#x27;</span>)</span><br></pre></td></tr></table></figure><h2 id="参考文献">参考文献</h2><p><ahref="https://github.com/rlabbe/Kalman-and-Bayesian-Filters-in-Python">Kalmanand Bayesian Filters in Python</a></p>]]></content>
      
      
      <categories>
          
          <category> 贝叶斯滤波器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滤波器 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贝叶斯滤波器系列(3) - 贝叶斯学派</title>
      <link href="/2025/09/01/BF03/"/>
      <url>/2025/09/01/BF03/</url>
      
        <content type="html"><![CDATA[<h1 id="贝叶斯学派">贝叶斯学派</h1><h2 id="引言">1 引言</h2><blockquote>概率论只不过是把常识用数学公式表达了出来。<p align="right">————拉普拉斯</p></blockquote><table><tr><td rowspan="3"><img src="https://imgs.xkcd.com/comics/frequentists_vs_bayesians.png"></td></tr><tr><td><div>太阳刚刚爆炸了吗？（现在是晚上，所以我们不确定）</div><div> </div><div>这个中微子探测仪能测量出太阳有没有变成新星。然后，它会掷2颗般子。如果都是6，它就说谎话。否则，就说真话。</div><div>来试试吧。探测仪！太阳有没有变成新星？</div><div>探测仪：YES。</div><div> </div><div>频率学派统计学家：这个结果出现的概率是 1/36=0.027 , 因为p 小于0.05，我认为太阳爆炸了。</div><div> </div><div>贝叶斯学派统计学家：老子赌50块它没有。</div><div> </div><div> </div><div>“探测仪，如果我问一个贝叶斯学派的统计学家如……”</div><div>“[ding]我是一个中微子探测仪，不是迷宫守卫。你是不是脑子坏掉了?”</div><div>“[ding]…yes”</div></td></tr></table><h2 id="贝叶斯定理bayes-theorem">2 贝叶斯定理（Bayes Theorem）</h2><h3 id="例子">2.1 例子</h3><p>先来做个有奖竞猜：<br />&gt; Steve非常害羞而且性格孤僻，虽然总是乐于助人，但对周围的人或现实世界几乎不感兴趣，他是一个温顺而又井井有条（meekand tidy）的人，需要事情有条理且结构清晰，并乐于钻研细节。<br />&gt; 请问 “Steve 是个图书管理员” 和 “Steve 是个农民”这两种说法哪种可能性更大？</p><p>5</p><p>4</p><p>3</p><p>2</p><p>1</p><p>这个例子是心理学家、诺贝尔经济学奖获得者 Daniel Kahneman 和 AmosTversky 发表于《Science》上的文章《Judgment under Uncertainty:Heuristics andBiases》的例子(<del>飘了，都敢读《science》了，也是好起来了</del>)。根据Kahneman 和 Tversky 的实验结果，当人们知道 Steve是“一个温顺而又井井有条的人”后，大多数人都会说他更有可能是图书馆管理员，毕竟与农民相比，这些特征更符合图书馆管理员的形象。但实际上这是错误的、非理性的。Why?</p><p>问题的关键不是图书管理员或人们的形象如何，而是在判断时人们并没有将农民与图书管理员的比例考虑进去。</p><blockquote><ul><li>2020年第七次全国人口普查：居住在乡村的人口为 509787562人；《北京师范大学学报（社会科学版）》2021 年第 6期《中国农民规模问题的不同判断、认知误区与治理优化》：2020年农业劳动者人数 1.77 亿人。<br /></li><li>《智研年榜：2023年中国各地区公共图书馆数量排行榜单TOP31》：2023年全国共建有 3246 个公共图书馆。</li></ul></blockquote><p>根据上述资料我们假设每个图书馆都有 100 名工作人员，那么其比例约为<spanclass="math inline">1.77 × 10<sup>9</sup> : 3246 × 10<sup>2</sup> = 5452.86 : 1</span>，我们取比例为<span class="math inline">5000 : 10</span>。(论文中使用的比例为<spanclass="math inline">20 : 1</span>)<br />如果符合之前描述特征的农民比例为 <span class="math inline">1%</span>，而符合描述的图书管理员比例为 <span class="math inline">90%</span>,我们可以得到 <spanclass="math display">5000 × 0.01 : 10 × 0.9 = 50 : 9</span> 你看，“Steve是个图书管理员” 这一说法的正确的可能性只有 <spanclass="math inline">17.7%</span> 。</p><p>事实上我们并不期望所有被问这个问题的人都有准确的关于农民、图书馆管理员以及他们的性格特点的统计信息，但问题是人们是否有考虑过这个比例？从而至少能够进行一个粗略的估计。理性不是说知道事实，而是认识到哪些因素是有关的。</p><p>如果你能理解这样的想法，即 <strong>“看到证据” 限制了 “概率空间”后再考虑比例</strong>，那么恭喜你已经理解了贝叶斯定理的精髓。或许你要估计的数字各不相同，但重要的是你如何将这些数字组合起来根据证据来更新你的看法。</p><h3 id="定义">2.2 定义</h3><p>设事件组 <spanclass="math inline"><em>A</em><sub>1</sub>, <em>A</em><sub>2</sub>, ⋯<em>A</em><sub><em>n</em></sub></span>为样本空间 <span class="math inline"><em>Ω</em></span>的一个完备事件组，且 <spanclass="math inline"><em>P</em>(<em>A</em><sub><em>i</em></sub>) &gt; 0</span>,<span class="math inline"><em>B</em></span> 为满足 <spanclass="math inline"><em>P</em>(<em>B</em>) &gt; 0</span> 的任一事件，则<span class="math display">$$P(A \mid B)=\frac{P(A) P(B \mid A)}{P(B)}$$</span> 写成标准形式 <span class="math display">$$P\left(A_{i} \mid B\right)=\frac{P\left(A_{i}\right) P\left(B \midA_{i}\right)}{\sum_{i=1}^{n} P\left(A_{i}\right) P\left(B \midA_{i}\right)}$$</span> 一般情况下，我们称 - <spanclass="math inline"><em>P</em>(<em>A</em>|<em>B</em>)</span> 是已知<span class="math inline"><em>B</em></span> 发生后，<spanclass="math inline"><em>A</em></span> 的条件概率，也称作 <spanclass="math inline"><em>A</em></span> 的后验概率。 - <spanclass="math inline"><em>P</em>(<em>A</em>)</span> 是 <spanclass="math inline"><em>A</em></span> 的先验概率。 - <spanclass="math inline"><em>P</em>(<em>B</em>|<em>A</em>)</span> 是已知<span class="math inline"><em>A</em></span> 发生后，<spanclass="math inline"><em>B</em></span> 的条件概率。也可称为 <spanclass="math inline"><em>B</em></span> 的后验概率。某些文献又称其为在特定<span class="math inline"><em>B</em></span> 时，<spanclass="math inline"><em>A</em></span> 的似然性，因为 $P(B|A)=L(A|B) $。- <span class="math inline"><em>P</em>(<em>B</em>)</span> 是 <spanclass="math inline"><em>B</em></span> 的先验概率。</p><p>啥？看不懂？莫慌这不还有我我，且听我娓娓道来。（概率论第二章条件概率之后就是这节内容🤭）</p><h3 id="直观理解一">2.3 直观理解（一）</h3><p>回到开篇的例子中。问题可以转化为 “符合描述的 Steve 是图书管理员的概率<spanclass="math inline"><em>P</em>(<em>A</em><sub>1</sub>|<em>B</em>)</span>”和 “符合描述的 Steve 是农民的概率 <spanclass="math inline"><em>P</em>(<em>A</em><sub>2</sub>|<em>B</em>)</span>”哪一个更大？<br />- 让我们再捋一下问题的逻辑(逆向):我们进行了一次观测/试验，怎么说都好，总之我们拿到了新的信息 “Steve的特征”。这个时候我们想要去推算 <strong><em>“当 Steve 符合特征( <spanclass="math inline"><em>B</em></span> )时，他是个图书管理员( <spanclass="math inline"><em>A</em><sub>1</sub></span> )的概率 <spanclass="math inline"><em>P</em>(<em>A</em><sub>1</sub>|<em>B</em>)</span>”</em></strong>。<br />- 或者换个方向(正向): 我们计算事件 <strong><em>“Steve是个符合描述的图书管理员的概率 <spanclass="math inline"><em>P</em>(<em>A</em><sub>1</sub><em>B</em>)</span>”</em></strong>就应该等价于 <strong><em>“假设 Steve 是个图书管理员 <spanclass="math inline"><em>P</em>(<em>A</em><sub>1</sub>)</span>” 并且“图书管理员符合描述 <spanclass="math inline"><em>P</em>(<em>B</em>|<em>A</em><sub>1</sub>)</span>的概率”</em></strong> 。</p><p>逻辑清晰后就可以写出公式了 <span class="math display">$$P(A_1|B) = \frac{P(A_1B)}{P(B)} = \frac{P(A_1)P(B|A_1)}{P(B)}$$</span> &gt; 这里第一个等号是条件概率公式，也就是说 P(B)是作为归一化系数存在的，这也解释了为什么会有全概率公式的存在。如果当时没学明白可以看下一部分(其实自己画画Venn 图就知道了)。</p><p>哇哦!非常Amazing啊!竟然是贝叶斯公式耶。</p><p>到这里就可以对各种名词有个直观的感觉了。 -先验概率就是在检验发生以前(获得新的信息之前)，我们已经掌握的信息。本例中就是“Steve 是个图书管理员的概率 <spanclass="math inline"><em>P</em>(<em>A</em><sub>1</sub>)</span>”。 -后验概率就是在检验发生以后(获得新的信息之后)，我们对旧信息进行的更新。本例中就是“符合描述的 Steve 是图书管理员的概率 <spanclass="math inline"><em>P</em>(<em>A</em><sub>1</sub>|<em>B</em>)</span>”。-似然概率就是当检验呈现某种结果时，我们对检验参数的估计正确的可能性。本例中就是“假设参数是’图书管理员’的情况下，检验结果为’符合描述’时，我们的假设正确的可能性”；或者说“图书管理员符合描述的概率 <spanclass="math inline"><em>P</em>(<em>B</em>|<em>A</em><sub>1</sub>)</span>”。</p><blockquote><p>我知道似然概率和前两个相比很抽象，因为他们的底层逻辑是不同的。先验与后验概率属于”概率论”，而”似然性”则来自与”数理统计”。(给出几个关键词：极大似然思想，费舍尔信息)<br />贝叶斯估计和极大似然估计的区别是：极大似然估计中要估计的参数是个一般变量，而贝叶斯估计中要估计的参数是个随机变量。</p></blockquote><h3 id="直观理解二">2.4 直观理解（二）</h3><p>现在再次回到例子中，使用古典概型的方法再捋一遍：<br />农民有 <span class="math inline">50000</span> 人，其中 <spanclass="math inline">1%</span> 符合描述，所以符合描述的就是 <spanclass="math inline">50000 * 1% = 500</span> 人；图书管理员有 <spanclass="math inline">10</span> 人，其中 <spanclass="math inline">90%</span> 符合描述，所以符合描述的就是 <spanclass="math inline">10 * 90% = 9</span> 人。<br />所以符合描述的时，是图书管理员的概率即为 <span class="math display">$$\begin{align}    \nonumber   P(A_1|B) &amp;= \frac{(A_1) \times P(B|A_1)}{(A_1)\times P(B|A_1) +  (A_2) \times P(B|A_2)}\\    \nonumber            &amp;= \frac{10 \times 0.9}{10 \times 0.9 + 500\times 0.01}\\    \nonumber            &amp;= \frac{9}{9 + 500}\end{align}$$</span></p><p>所以贝叶斯定理是在说：你有一些假设(像是“Steve是个图书管理员”)，同时你得到了一些证据(比如 Steve是个温顺而又并并有条的人), 然乎你想知道在 “你得到的证据是真的” 的条件下“你的假设成立” 的概率。</p><h2 id="贝叶斯学派-v.s.-频率学派">3 贝叶斯学派 V.S. 频率学派</h2><p>贝叶斯推断方法的关键是任何推断都必须且只须根据后验分布，而不能再涉及样本分布。<br />贝叶斯学派与频率学派争论的焦点在于先验分布。贝叶斯学派认为先验分布可以是主观的，它不需要有频率解释。而频率学派则认为，只有在先验分布有一种不依赖主观的意义，且能根据适当的理论或以往的经验决定时，才允许在统计推断中使用先验分布，否则就会丧失客观性。<br />（但这样的话其实有个悖论：频率学派进行重复实验时认为每次实验都是独立的，如果有<spanclass="math inline"><em>P</em>(<em>A</em><em>B</em>) = <em>P</em>(<em>A</em>)<em>P</em>(<em>B</em>)</span>则事件相互独立，这里假定了独立再去检验独立，也很奇怪。） 1.频率论先建立无效模型，然后计算在此无效模型的前提下得到从实际数据中得来的参数的可能性，假如这个可能性很小，我们就认为无效模型不成立，从而选择备择模型（假设检验）；而贝叶斯论关注于在当前数据的前提下，某个模型成立的概率，得到的是具体的概率值，而该概率值不用于对某个假说的判断。<br />2.频率论对概率的解释是：一个事件在一段较长的时间内发生的频率；贝叶斯论对概率的解释是人们对某事件是否发生的认可程度。<br />3.贝叶斯论善于利用过去的知识和抽样数据，而频率论仅仅利用抽样数据。因此贝叶斯推论中前一次得到的后验概率分布可以作为后一次的先验概率。<br />4.对置信区间的不同解释：频率论中95%置信区间解释为：100次抽样计算得到的100个置信区间中有95个包含了总体参数，5个没有，而不能解释成在一次抽样中有95%的可能性包含总体参数。这是由于经典统计中总体的参数是被当作一个恒定值的，不能从概率的角度解释；贝叶斯论的置信区间恰好可以解释成概率的形式，因为贝叶斯分析中，总体参数是个随机变量，而非恒定值。</p><p>贝叶斯的好处在于贝叶斯的推断问题相对简单，点估计，区间估计和假设检验全部可以由后验分布得到，尤其是计算机技术的发展和MCMC (Markov Chain Monte Carlo)方法的出现提供了从后验分布直接抽样的途径,使得非共轭后验分布的使用和计算成为可能。</p><h2 id="后记">4 后记</h2><p>其实 Kahneman 和 Tversky 还有一个实验，和 Steve的那个非常相似。在这个实验中，他俩描述了一个虚构的女人，叫 Linda，Linda31岁、单身、坦率、而且非常聪明，主修哲学，作为一名学生，她非常关心歧视和社会公平问题，而且还参加反核游行示威活动。</p><p>当人们听到这样一个描述后，被问下面哪一种说法更有可能：（1）Linda是一个银行出纳员；（2）Linda是一个银行出纳员同时也是女权运动中的一个积极分子。85%的参与者说后者更有可能，尽管“是银行出纳员同时也是女权运动中的一个积极分子”是“银行出纳员”的一个子集。</p><h2 id="参考文献">5 参考文献</h2><p><ahref="https://www.science.org/doi/10.1126/science.185.4157.1124">AmosTversky, Daniel Kahneman ,Judgment under Uncertainty: Heuristics andBiases.Science185,1124-1131(1974).DOI:10.1126/science.185.4157.1124</a></p>]]></content>
      
      
      <categories>
          
          <category> 贝叶斯滤波器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滤波器 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贝叶斯滤波器系列(2) - 滑动滤波</title>
      <link href="/2025/09/01/BF02/"/>
      <url>/2025/09/01/BF02/</url>
      
        <content type="html"><![CDATA[<h1 id="滑动滤波">1 滑动滤波</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># %matplotlib widget</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> MyFilter.MovingAverageFilter <span class="keyword">as</span> MAF</span><br><span class="line"><span class="keyword">import</span> MyFilter.FilterPerformance <span class="keyword">as</span> FP</span><br><span class="line"><span class="keyword">import</span> MyFilter.UserLib <span class="keyword">as</span> UserLib</span><br><span class="line">figsize=(<span class="number">25</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><p>在第一节中，我们讨论了对于静态目标的测量噪声的抑制方法。我们认为测量过程中的所有信息都是有效且平权的，所以采取的最直接的方法————累计平均（CumulativeAverage）。但实际应用中，我们往往面对着动态过程的测量，比如测量一辆匀加速运动中小车的实时速度。这种情况下，使用累计平均来进行滤波显然是不可靠的。Why？<br />1. 从数学模型上来说，CA滤波器在对系统建模时认为其是完全不变的 ————&gt;同一滤波器对不同模型的所表现出的性能是不同的。 2.从性能分析上来说，滤波器的性能可以分为静态性能(对噪声的抑制能力)与动态性能(对真值变化的跟踪能力)————&gt; 选择滤波器时应综合考虑。 &gt;如果在我自己浅薄的知识范围内对所有滤波器的工作原理进行分析的话应该是————运用合理的数学方法对信息进行提取与融合。<br />&gt; 每次测量的结果都可以视为<spanclass="math inline"><em>真</em><em>值</em> + <em>噪</em><em>声</em></span>对于单一结果的话我们无法区分每种成分所占的比例(我们所拥有的信息太少了)。但是，每一次新的测量都会带来新的信息(新息序列)，利用合理的数学方法将其中的信息提取出来的过程便是滤波。从过去的数据中提取出信息，再与新息进行融合，从而得到一个更可靠的数值。<br />&gt;&gt;本教程大多讨论滤波器的时域性能而非频域性能，一般来说滤波器的时域性能与频域性能是互斥的。而我写这个教程的初衷是希望新生能够对传感器的数据(加速度、角速度、磁场和电压等等物理量)进行有效提取，而非对频域上的信号进行分离，故FIR与IIR滤波器不做重点讨论。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 模型参数 ###</span></span><br><span class="line"><span class="comment"># 采样参数</span></span><br><span class="line">SampleFre = <span class="number">10</span></span><br><span class="line">TotalTime = <span class="number">10</span>          <span class="comment"># 采样时间 不推荐大于10, 增加点数请增大采样率</span></span><br><span class="line">Step = <span class="number">1</span>/SampleFre</span><br><span class="line">SampleNum = SampleFre * TotalTime</span><br><span class="line"><span class="comment"># 模型参数</span></span><br><span class="line">Model_accel = <span class="number">3</span></span><br><span class="line">Model_initialSpeed = <span class="number">5</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ModelValue, ActualValue, MeasureValue = UserLib.Model.Generative(Step, TotalTime, <span class="keyword">lambda</span> x: Model_accel * x + Model_initialSpeed)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 绘图展示 ###</span></span><br><span class="line">plt.figure(figsize=figsize)</span><br><span class="line">plt.plot(ModelValue, <span class="string">&#x27;.-&#x27;</span>, label=<span class="string">&quot;Model&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(ActualValue, <span class="string">&#x27;*-&#x27;</span>, label=<span class="string">&quot;Actual&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(MeasureValue, <span class="string">&#x27;o-&#x27;</span>, label=<span class="string">&quot;Measure&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower right&#x27;</span>) <span class="comment">#绘制图例</span></span><br></pre></td></tr></table></figure><p><imgsrc="/images/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_files/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_5_1.png" /></p><p>OK我们现在已经获得了可以用来仿真的模型，可以很直观的看到噪声的影响对吧。但在现实中我们根本不可能获得真实的模型，我们只能看到测量值，所以在工程应用我们获得的数据大概是这个样子的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">plt.figure(figsize=figsize)</span><br><span class="line"><span class="comment"># def linear_regression(x, y): </span></span><br><span class="line"><span class="comment">#     N = len(x)</span></span><br><span class="line"><span class="comment">#     sumx = sum(x)</span></span><br><span class="line"><span class="comment">#     sumy = sum(y)</span></span><br><span class="line"><span class="comment">#     sumx2 = sum(x**2)</span></span><br><span class="line"><span class="comment">#     sumxy = sum(x*y)</span></span><br><span class="line"><span class="comment">#     A = np.asmatrix([[N, sumx], [sumx, sumx2]])</span></span><br><span class="line"><span class="comment">#     b = np.array([sumy, sumxy])</span></span><br><span class="line"><span class="comment">#     return np.linalg.solve(A, b)</span></span><br><span class="line"><span class="comment"># # 绘制拟合直线</span></span><br><span class="line"><span class="comment"># b, k = linear_regression(np.arange(0, np.size(MeasureValue)), MeasureValue)</span></span><br><span class="line"><span class="comment"># plt.plot(range(0, np.size(MeasureValue)), [k * x + b for x in range(0, np.size(MeasureValue))], &#x27;ro-&#x27;) </span></span><br><span class="line"><span class="comment"># plt.title(&quot;y = &#123;&#125; + &#123;&#125;x&quot;.format(b, k)) </span></span><br><span class="line"><span class="comment"># 绘制带误差线的测量数据</span></span><br><span class="line">plt.errorbar(<span class="built_in">range</span>(<span class="number">0</span>, np.size(MeasureValue)), MeasureValue, yerr=np.std(MeasureValue), fmt=<span class="string">&#x27;bo&#x27;</span>, capthick=<span class="number">2</span>, capsize=<span class="number">10</span>)</span><br></pre></td></tr></table></figure><p><imgsrc="/images/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_files/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_7_1.png" /></p>通常我们是无法确定系统的模型的。在图中我们可以感觉到是上升趋势，但如何按照什么趋势上升我们是无法确定的。也许你可能会想用最小二乘法拟合一下不就能知道系统的大概情况了？取消上方的注释，运行，完美！系统的参数基本被成功辨识出来了。但你忽略了一个前提条件，上方的最小二乘是一元线性回归，也就是说<strong>引入了一个前提条件</strong>:这是一个线性系统。这个前提条件所携带的信息量是十分巨大的，因此系统才能被近乎完美的辨识出来。<br />在这里我们可以大致给接下来要讲的滤波器分为两类： 1.不知道模型，单纯通过某种形式上的低通滤波器来对噪声进行抑制。 2.假定模型是线性的(或通过某种方法使数据变为线性分布的)，在模型的基础上对噪声进行抑制。### 1.1 简单滑动滤波(SMA, Simple Moving Average) #### 1.1.1 介绍那么在平均滤波的框架内，如何改变CA滤波器使之具有更好的动态性能呢？最朴素的想法，把以前的数据丢了不就好了？你说得对，极对，恭喜你发现了滑动滤波。<br />系统一点的说法应该是，对于系统当前的状态，早期测量得到的数据是错误的，存在较大偏差，提供了错误的信息，用错误的信息当然会得到错误的结论；而比较新的数据里面包含的信息相对准确，使用准确的信息才能得到准确的结果。<br />而将以前的数据丢掉这个过程，在数学上看来是一个加权过程，早期的数据是不重要的，因此具有权值’0’;近期的数据是平等重要的，故具有相同的权值‘<spanclass="math inline">1/<em>n</em></span>’。 &gt;这个过程实际上是一个卷积过程，我们所说的权值的分布对应着卷积核的构造。这里坑太深，不做展开，但强烈建议弄清楚。&gt;<div align=center><blockquote><p><img src="https://upload.wikimedia.org/wikipedia/commons/b/b9/Convolution_of_spiky_function_with_box2.gif" width="941" height="250" /></p></div><p>对一个卷积核长度为 n 的 SMA 滤波器，其数学形式应该为 <spanclass="math display">$$\hat{x} = \frac{1}{n} \cdot \sum_{i=0}^{n-1}x_{N-i}$$</span> 式中 N 为当前采样序列长度(当前时刻)。使用瞪眼法写出递推公式<span class="math display">$$\hat{x} = \hat{x}_{last} + \frac{1}{n} \cdot (x_M - x_{M-n})$$</span> #### 1.1.2 python 实现 SMA class 在 python 中的实现如下<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleMovingAverageFilter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, window_size</span>):</span><br><span class="line">        <span class="variable language_">self</span>.window_size = window_size</span><br><span class="line">        <span class="variable language_">self</span>.window = []</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, new_value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.window.append(new_value)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.window) &gt; <span class="variable language_">self</span>.window_size:</span><br><span class="line">            <span class="variable language_">self</span>.window.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="variable language_">self</span>.window) / <span class="built_in">len</span>(<span class="variable language_">self</span>.window)</span><br></pre></td></tr></table></figure> 仅供参考，从没学过 python，就是凭着感觉随手写写+面向谷哥编程。把面向对象语言当面向过程写，丑陋至极😓。#### 1.1.3 性能分析虽然之前一直在灌输性能包含两部分（动态+静态），但在分析时分开测试是没有意义的。因为对于噪声来说，一定是滤波核长度越长效果越好，同时动态性能也在下降。这两部分构成了一个有机整体，无法独立去判断；这两个指标除了理论上存在的意义之外，更多的是在横向比较时提供一种参照，即滤波器a 在什么参数下与滤波器 b近似相等。故在独立分析的部分中不会分别讨论静态/动态性能。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">moveFilter = MAF.SimpleMovingAverageFilter(<span class="number">5</span>)</span><br><span class="line">FilterValue = moveFilter.refilter(MeasureValue)</span><br><span class="line"><span class="comment">### 绘图展示 ###</span></span><br><span class="line">plt.figure(figsize=figsize)</span><br><span class="line">plt.plot(ModelValue, <span class="string">&#x27;.-&#x27;</span>, label=<span class="string">&quot;Model&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(ActualValue, <span class="string">&#x27;*-&#x27;</span>, label=<span class="string">&quot;Actual&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(MeasureValue, <span class="string">&#x27;-&#x27;</span>, label=<span class="string">&quot;Measure&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(FilterValue, <span class="string">&#x27;o-&#x27;</span>, label=<span class="string">&quot;Filter&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower right&#x27;</span>) <span class="comment">#绘制图例</span></span><br><span class="line">FP.FilterPerformance.analysis(FilterValue, MeasureValue, ActualValue)</span><br></pre></td></tr></table></figure><p><imgsrc="/images/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_files/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_11_0.png" /></p><p><imgsrc="/images/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_files/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_11_1.png" /></p><p>经过滤波器后，噪声受到了明显的抑制，对目标也有较好的跟踪能力。接下来进行进一步的分析。首先分析滤波核长度对噪声抑制能力的影响。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bias0    = []</span><br><span class="line">bias1    = []</span><br><span class="line">redratio = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20</span>):</span><br><span class="line">    moveFilter = MAF.SimpleMovingAverageFilter(i)</span><br><span class="line">    FilterValue = moveFilter.refilter(MeasureValue)</span><br><span class="line">    bias0.append(np.mean(<span class="built_in">abs</span>(np.array(MeasureValue) - np.array(ActualValue))))</span><br><span class="line">    bias1.append(np.mean(<span class="built_in">abs</span>(np.array(FilterValue) - np.array(ActualValue))))</span><br><span class="line">    redratio.append(<span class="number">1</span> - bias1[-<span class="number">1</span>] / bias0[-<span class="number">1</span>])</span><br><span class="line">fig = plt.figure(figsize=figsize)</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">ax.plot(<span class="built_in">range</span>(<span class="number">1</span>, np.size(bias1)+<span class="number">1</span>), bias1, <span class="string">&#x27;-o&#x27;</span>, label=<span class="string">&quot;Mean abs bias&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">ax.legend(loc=<span class="string">&#x27;lower left&#x27;</span>)</span><br><span class="line">ax2 = ax.twinx()</span><br><span class="line">ax2.plot(<span class="built_in">range</span>(<span class="number">1</span>, np.size(redratio)+<span class="number">1</span>), redratio, <span class="string">&#x27;-ob&#x27;</span>, label=<span class="string">&quot;Reduction ratio&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">ax2.legend(loc=<span class="string">&#x27;lower right&#x27;</span>)</span><br><span class="line">plt.suptitle(<span class="string">f&#x27;Max average deviation reduction ratio:<span class="subst">&#123;np.array(redratio).<span class="built_in">max</span>()*<span class="number">100</span>:<span class="number">.3</span>f&#125;</span>% at <span class="subst">&#123;np.array(redratio).argmax() + <span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line">plt.plot(np.array(redratio).argmax() + <span class="number">1</span>, np.array(redratio).<span class="built_in">max</span>(), <span class="string">&#x27;*g&#x27;</span>, markersize=<span class="number">10</span>)</span><br><span class="line">plt.axhline(np.array(redratio).<span class="built_in">max</span>(), color=<span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure><p><imgsrc="/images/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_files/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_13_1.png" /></p><blockquote><p>(这里并没有多次实验来得到普遍规律，因为每次都重新仿真对性能要求较高。不妨手动重新运行几次，<del>绝对不是我懒得写😝</del>)这里规律大致是： 1. 滤波核长度[1,7]:噪声大小下降。且带有明显的边际效应，1<sub>3快速下降，4</sub>7下降较为缓慢。2. 滤波核长度[8,13]：噪声基本不变。在这段区间内噪声大小基本维持在固定水平内，原因是新息所带来的对噪声抑制效果和利用旧模型对前状态推断所产生的错误相抵消。3. 滤波核长度[13,~]:噪声大小增加。模型的错误信息过多，使误差增大。也好理解 SMA滤波器在极限情况下就是 CA 滤波器嘛。需要注意的是，上述规律并不是固定的，其潜在条件不光有噪声的方差更有模型的参数，切勿死记硬背。<br />就像上一节使用中心极限定理时，我既没有说“列维－林德伯格中心极限定理”，也没有说”棣莫弗－拉普拉斯中心极限定理”，这两个教材上的定理都要求独立同分布，但我们使用的则是更一般化的结论；又或者刚刚用一元线性回归举的例子。不要被垃圾学校的考试带跑偏，以为背背就完了；工程像是一场解谜游戏，需要融会贯通、学以致用，咱玩的是四两拨千斤。</p></blockquote><h2 id="加权滑动滤波wma-weithed-moving-average">1.2 加权滑动滤波(WMA,Weithed Moving Average)</h2><h3 id="介绍">1.2.1 介绍</h3><p>在简单滑动滤波中，我们认为滤波核内的信息是同等重要的。而加权滑动滤波则给予滤波核内数据不同的权值。一般常见的权值构造为三角形。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window_size = <span class="number">20</span></span><br><span class="line">kernel = []</span><br><span class="line">normal_Coefficient = window_size * (window_size + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(window_size):</span><br><span class="line">    kernel.append(i / normal_Coefficient)</span><br><span class="line">fig = plt.figure(figsize=(<span class="number">25</span>, <span class="number">5</span>))</span><br><span class="line">ax = fig.add_subplot(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">ax.plot(kernel, <span class="string">&#x27;-o&#x27;</span>, label=<span class="string">&quot;kernel&quot;</span>, markersize=<span class="number">10</span>)</span><br><span class="line">ax.legend(loc=<span class="string">&#x27;lower right&#x27;</span>)</span><br><span class="line">plt.suptitle(<span class="string">&#x27;WMA kernel&#x27;</span>)</span><br></pre></td></tr></table></figure><pre><code>Text(0.5, 0.98, &#39;WMA kernel&#39;)</code></pre><p><imgsrc="/images/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_files/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_16_1.png" /></p><h3 id="python-实现">1.2.2 python 实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WeightedMovingAverageFilter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, window_size</span>):</span><br><span class="line">        <span class="variable language_">self</span>.window_size = window_size</span><br><span class="line">        <span class="variable language_">self</span>.kernal = []</span><br><span class="line">        <span class="variable language_">self</span>.window = []</span><br><span class="line">        normal_Coefficient = window_size * (window_size + <span class="number">1</span>) / <span class="number">2</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(window_size):</span><br><span class="line">            <span class="variable language_">self</span>.kernal.append((i + <span class="number">1</span>) / normal_Coefficient)       </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, new_value</span>):</span><br><span class="line">        <span class="variable language_">self</span>.window.append(new_value)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(<span class="variable language_">self</span>.window) &gt; <span class="variable language_">self</span>.window_size:</span><br><span class="line">            <span class="variable language_">self</span>.window.pop(<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span>([<span class="variable language_">self</span>.window[i] * <span class="variable language_">self</span>.kernal[i] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(<span class="variable language_">self</span>.window))])</span><br></pre></td></tr></table></figure><h3 id="性能分析">1.2.3 性能分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">moveFilter = MAF.WeightedMovingAverageFilter(<span class="number">5</span>)</span><br><span class="line">FilterValue = moveFilter.refilter(MeasureValue)</span><br><span class="line"><span class="comment">### 绘图展示 ###</span></span><br><span class="line">plt.figure(figsize=(<span class="number">25</span>, <span class="number">5</span>))</span><br><span class="line">plt.plot(ModelValue, <span class="string">&#x27;.-&#x27;</span>, label=<span class="string">&quot;Model&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(ActualValue, <span class="string">&#x27;*-&#x27;</span>, label=<span class="string">&quot;Actual&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(MeasureValue, <span class="string">&#x27;-&#x27;</span>, label=<span class="string">&quot;Measure&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(FilterValue, <span class="string">&#x27;o-&#x27;</span>, label=<span class="string">&quot;Filter&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower right&#x27;</span>) <span class="comment">#绘制图例</span></span><br><span class="line">FP.FilterPerformance.analysis(FilterValue, MeasureValue, ActualValue)</span><br></pre></td></tr></table></figure><p>如果初值没有设为 0的话，应该可以明显注意到前几个点存在迅速下降的巨大误差。这是因为滤波器初始化时窗口内部全零填充导致的，这段时间被称为滤波器的启动时间/warm-up时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bias0    = []</span><br><span class="line">bias1    = []</span><br><span class="line">redratio = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20</span>):</span><br><span class="line">    moveFilter = MAF.WeightedMovingAverageFilter(i)</span><br><span class="line">    FilterValue = moveFilter.refilter(MeasureValue)</span><br><span class="line">    bias0.append(np.mean(<span class="built_in">abs</span>(np.array(MeasureValue) - np.array(ActualValue))))</span><br><span class="line">    bias1.append(np.mean(<span class="built_in">abs</span>(np.array(FilterValue) - np.array(ActualValue))))</span><br><span class="line">    redratio.append(<span class="number">1</span> - bias1[-<span class="number">1</span>] / bias0[-<span class="number">1</span>])</span><br><span class="line">fig = plt.figure(figsize=figsize)</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">ax.plot(<span class="built_in">range</span>(<span class="number">1</span>, np.size(bias1)+<span class="number">1</span>), bias1, <span class="string">&#x27;-o&#x27;</span>, label=<span class="string">&quot;Mean abs bias&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">ax.legend(loc=<span class="string">&#x27;lower left&#x27;</span>)</span><br><span class="line">ax2 = ax.twinx()</span><br><span class="line">ax2.plot(<span class="built_in">range</span>(<span class="number">1</span>, np.size(redratio)+<span class="number">1</span>), redratio, <span class="string">&#x27;-ob&#x27;</span>, label=<span class="string">&quot;Reduction ratio&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">ax2.legend(loc=<span class="string">&#x27;lower right&#x27;</span>)</span><br><span class="line">plt.suptitle(<span class="string">f&#x27;Max average deviation reduction ratio:<span class="subst">&#123;np.array(redratio).<span class="built_in">max</span>()*<span class="number">100</span>:<span class="number">.3</span>f&#125;</span>% at <span class="subst">&#123;np.array(redratio).argmax() + <span class="number">1</span>&#125;</span>&#x27;</span>)</span><br><span class="line">plt.plot(np.array(redratio).argmax() + <span class="number">1</span>, np.array(redratio).<span class="built_in">max</span>(), <span class="string">&#x27;*g&#x27;</span>, markersize=<span class="number">10</span>)</span><br><span class="line">plt.axhline(np.array(redratio).<span class="built_in">max</span>(), color=<span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure><p><imgsrc="/images/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_files/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_20_1.png" /></p><h2 id="指数滑动滤波ema-exponential-moving-average">1.3指数滑动滤波(EMA, Exponential Moving Average)</h2><h3 id="介绍-1">1.3.1 介绍</h3><h4 id="表达式的推导">1.3.1.1 表达式的推导</h4><p>指数滑动滤波是以指数形式构造其滤波核的滤波器。各数值的加权影响力随时间而指数式递减，越近期的数据加权影响力越重，但较旧的数据也给予一定的加权值。根据定义直接写出其权重序列<span class="math inline">{<em>w</em><sub><em>i</em></sub>}</span>及估值表达式 <span class="math inline"><em>x̂</em></span> <spanclass="math display">$$w_i = \frac{(1-\alpha)^i}{\sum_{i=0}^n{(1-\alpha)^i}}$$</span> <span class="math display">$$\hat{x}_{n+1} = \frac{(1-\alpha)^0x_{n+1} + (1-\alpha)^1x_{n} +(1-\alpha)^2x_{n-1} + \cdots +(1-\alpha)^nx_{1}}{\sum_{i=0}^n{(1-\alpha)^i}}$$</span> 注意到 <span class="math display">$$\lim_{n-&gt;\infty}\sum_{i=0}^n{(1-\alpha)^i} = \lim_{n-&gt;\infty}\frac{1 \cdot (1 - (1-\alpha)^n)}{1 - (1-\alpha)} = \frac {1}{\alpha}$$</span> 所以在极限情况下，估值表达式变为 <span class="math display">$$\begin{align}    \nonumber   \lim_{n\to \infty} \hat{x}_{n+1} &amp;= \alpha \cdot(x_{n+1} + (1-\alpha)^1x_{n} + \cdots + (1-\alpha)^nx_{1})\\    \nonumber   \lim_{n\to \infty} \hat{x}_{n+1} &amp;= \alpha \cdotx_{n+1} + (1-\alpha) \cdot [ \alpha \cdot (x_{n} + (1-\alpha)^1x_{n-1} +\cdots + (1-\alpha)^{n-1}x_{1})]\\    \nonumber   \lim_{n\to \infty} \hat{x}_{n+1} &amp;= \alpha \cdotx_{n+1} + (1-\alpha) \cdot \hat{x}_{n}\\    \nonumber   \lim_{n\to \infty} \hat{x}_{n+1} &amp;= \hat{x}_{n} +\alpha \cdot (x_{n+1} - \hat{x}_{n})\end{align}$$</span> 至此我们已经得到了具有应用价值的指数滤波的递推表达式。 ####1.3.1.2 半衰期 <span class="math display">$$\begin{align}   \nonumber   1 - (1-\alpha)^k &amp; = \frac{1}{2}\\   \nonumber   (1-\alpha)^k &amp; = \frac{1}{2}\\   \nonumber   k &amp; = -\ln {2} / \ln{(1-\alpha)}\\\end{align}$$</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">k = []</span><br><span class="line">com = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>):</span><br><span class="line">    k.append(- np.log(<span class="number">2</span>) / np.log(<span class="number">1</span> - i/<span class="number">100</span>))</span><br><span class="line">    com.append((<span class="number">1</span> - i/<span class="number">100</span>) / i/<span class="number">100</span>)</span><br><span class="line">fig = plt.figure(figsize=figsize)</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">ax.plot([i/<span class="number">100</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>)], k, <span class="string">&#x27;.-g&#x27;</span>, label=<span class="string">&quot;k&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">ax.legend(loc=<span class="string">&#x27;lower left&#x27;</span>)</span><br><span class="line">ax2 = ax.twinx()</span><br><span class="line">ax2.plot([i/<span class="number">100</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>)], com, <span class="string">&#x27;*-&#x27;</span>, label=<span class="string">&quot;com&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">ax2.legend(loc=<span class="string">&#x27;lower right&#x27;</span>)</span><br><span class="line">plt.grid(<span class="literal">True</span>)</span><br><span class="line">plt.suptitle(<span class="string">&quot;Half-life of EMA &amp; Center of Mass&quot;</span>)</span><br></pre></td></tr></table></figure><pre><code>Text(0.5, 0.98, &#39;Half-life of EMA &amp; Center of Mass&#39;)</code></pre><p><imgsrc="/images/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_files/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_22_1.png" /></p><h4 id="质心-com-center-of-mass">1.3.1.3 质心 (COM, Center Of Mass)</h4><p>由质心公式有 <span class="math display">$$\frac{\sum_{i=1}^{n} x_{i} m_{i}}{\sum_{i=1}^{n} m_{i}} =\sum_{i=0}^{\infty} i \cdot (1-\alpha)^i = x_{COM}$$</span> 由高中学过的错位相减有 <span class="math display">$$\begin{align}    \nonumber   x_{COM} - (1-\alpha) x_{COM} &amp; = \sum_{i=0}^{\infty} i \cdot (1-\alpha)^i - \sum_{i = 1}^{\infty} (i-1) \cdot(1-\alpha)^{i+1}\\    \nonumber   \alpha \cdot x_{COM} &amp; = (1-\alpha) -\lim_{i\to\infty}(i-1) \cdot (1-\alpha)^i\\    \nonumber   x_{COM} &amp; = \frac{(1-\alpha)}{ \alpha}\end{align}$$</span> 质心表征了“数据的重心”,显然质心越小说明估计值越接近测量值，半衰期越小。但问题是质心不够直观，为了让其具有更浅显的物理意义，我们将其映射为SMA 滤波核长度 L 。<br />假定 SMA 与 EMA 滤波核具有相同质心，则有 <span class="math display">$$\begin{align}    \nonumber   x_{COM, EMA} &amp;= x_{COM, SMA}\\    \nonumber   \frac{1-\alpha}{\alpha} &amp;= \frac{L}{2}\\    \nonumber   \alpha &amp;= \frac{2}{L+2}\end{align}$$</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">alpha = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>):</span><br><span class="line">    alpha.append(<span class="number">2</span> / (i + <span class="number">2</span>))</span><br><span class="line">fig = plt.figure(figsize=figsize)</span><br><span class="line">plt.plot(<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">21</span>), alpha, <span class="string">&#x27;-o&#x27;</span>, label=<span class="string">&quot;alpha&quot;</span>, markersize=<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><imgsrc="/images/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_files/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_24_1.png" /></p><h3 id="python-实现-1">1.3.2 python 实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ExponentialMovingAverageFilter</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, alpha</span>):</span><br><span class="line">        <span class="variable language_">self</span>.alpha = alpha</span><br><span class="line">        <span class="variable language_">self</span>.previous_value = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, new_value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="variable language_">self</span>.previous_value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="variable language_">self</span>.previous_value = new_value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="variable language_">self</span>.previous_value = <span class="variable language_">self</span>.alpha * new_value + (<span class="number">1</span> - <span class="variable language_">self</span>.alpha) * <span class="variable language_">self</span>.previous_value</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">self</span>.previous_value</span><br></pre></td></tr></table></figure><h3 id="性能分析-1">1.3.3 性能分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">moveFilter = MAF.ExponentialMovingAverageFilter(<span class="number">0.5</span>)</span><br><span class="line">FilterValue = moveFilter.refilter(MeasureValue)</span><br><span class="line"><span class="comment">### 绘图展示 ###</span></span><br><span class="line">plt.figure(figsize=(<span class="number">25</span>, <span class="number">5</span>))</span><br><span class="line">plt.plot(ModelValue, <span class="string">&#x27;.-&#x27;</span>, label=<span class="string">&quot;Model&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(ActualValue, <span class="string">&#x27;*-&#x27;</span>, label=<span class="string">&quot;Actual&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(MeasureValue, <span class="string">&#x27;-&#x27;</span>, label=<span class="string">&quot;Measure&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(FilterValue, <span class="string">&#x27;o-&#x27;</span>, label=<span class="string">&quot;Filter&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower right&#x27;</span>) <span class="comment">#绘制图例</span></span><br><span class="line">FP.FilterPerformance.analysis(FilterValue, MeasureValue, ActualValue)</span><br></pre></td></tr></table></figure><p><imgsrc="/images/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_files/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_26_0.png" /></p><p><imgsrc="/images/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_files/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_26_1.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bias0    = []</span><br><span class="line">bias1    = []</span><br><span class="line">redratio = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>):</span><br><span class="line">    moveFilter = MAF.ExponentialMovingAverageFilter(i/<span class="number">100</span>)</span><br><span class="line">    FilterValue = moveFilter.refilter(MeasureValue)</span><br><span class="line">    bias0.append(np.mean(<span class="built_in">abs</span>(np.array(MeasureValue) - np.array(ActualValue))))</span><br><span class="line">    bias1.append(np.mean(<span class="built_in">abs</span>(np.array(FilterValue) - np.array(ActualValue))))</span><br><span class="line">    redratio.append(<span class="number">1</span> - bias1[-<span class="number">1</span>] / bias0[-<span class="number">1</span>])</span><br><span class="line">fig = plt.figure(figsize=figsize)</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">ax.plot([i/<span class="number">100</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>)], bias1, <span class="string">&#x27;-o&#x27;</span>, label=<span class="string">&quot;Mean abs bias&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">ax.legend(loc=<span class="string">&#x27;lower left&#x27;</span>)</span><br><span class="line">ax2 = ax.twinx()</span><br><span class="line">ax2.plot([i/<span class="number">100</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>)],redratio, <span class="string">&#x27;-ob&#x27;</span>, label=<span class="string">&quot;Reduction ratio&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">ax2.legend(loc=<span class="string">&#x27;lower right&#x27;</span>)</span><br><span class="line">plt.suptitle(<span class="string">f&#x27;Max average deviation reduction ratio:<span class="subst">&#123;np.array(redratio).<span class="built_in">max</span>()*<span class="number">100</span>:<span class="number">.3</span>f&#125;</span>% at <span class="subst">&#123;(np.array(redratio).argmax() + <span class="number">1</span>)/<span class="number">100</span>&#125;</span>&#x27;</span>)</span><br><span class="line">plt.plot(np.array(redratio).argmax()/<span class="number">100</span> , np.array(redratio).<span class="built_in">max</span>(), <span class="string">&#x27;*g&#x27;</span>, markersize=<span class="number">10</span>)</span><br><span class="line">plt.axhline(np.array(redratio).<span class="built_in">max</span>(), color=<span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure><p><imgsrc="/images/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_files/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_27_1.png" /></p><h2 id="二阶指数滑动滤波dema-double-exponential-moving-average">1.4二阶指数滑动滤波(DEMA, Double Exponential Moving Average)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">moveFilter = MAF.DoubleExponentialMovingAverageFilter(<span class="number">0.22</span>)</span><br><span class="line">FilterValue = moveFilter.refilter(MeasureValue)</span><br><span class="line"><span class="comment">### 绘图展示 ###</span></span><br><span class="line">plt.figure(figsize=(<span class="number">25</span>, <span class="number">5</span>))</span><br><span class="line">plt.plot(ModelValue, <span class="string">&#x27;.-&#x27;</span>, label=<span class="string">&quot;Model&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(ActualValue, <span class="string">&#x27;*-&#x27;</span>, label=<span class="string">&quot;Actual&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(MeasureValue, <span class="string">&#x27;-&#x27;</span>, label=<span class="string">&quot;Measure&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(FilterValue, <span class="string">&#x27;o-&#x27;</span>, label=<span class="string">&quot;Filter&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower right&#x27;</span>) <span class="comment">#绘制图例</span></span><br><span class="line">FP.FilterPerformance.analysis(FilterValue, MeasureValue, ActualValue)</span><br></pre></td></tr></table></figure><p><imgsrc="/images/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_files/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_29_0.png" /></p><p><imgsrc="/images/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_files/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_29_1.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">bias0    = []</span><br><span class="line">bias1    = []</span><br><span class="line">redratio = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">100</span>, <span class="number">1</span>):</span><br><span class="line">    moveFilter = MAF.DoubleExponentialMovingAverageFilter(i/<span class="number">100</span>)</span><br><span class="line">    FilterValue = moveFilter.refilter(MeasureValue)</span><br><span class="line">    bias0.append(np.mean(<span class="built_in">abs</span>(np.array(MeasureValue) - np.array(ActualValue))))</span><br><span class="line">    bias1.append(np.mean(<span class="built_in">abs</span>(np.array(FilterValue) - np.array(ActualValue))))</span><br><span class="line">    redratio.append(<span class="number">1</span> - bias1[-<span class="number">1</span>] / bias0[-<span class="number">1</span>])</span><br><span class="line">fig = plt.figure(figsize=figsize)</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">ax.plot([i/<span class="number">100</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, bias1.__len__() + <span class="number">1</span>, <span class="number">1</span>)], bias1, <span class="string">&#x27;-o&#x27;</span>, label=<span class="string">&quot;Mean abs bias&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">ax.legend(loc=<span class="string">&#x27;lower left&#x27;</span>)</span><br><span class="line">ax2 = ax.twinx()</span><br><span class="line">ax2.plot([i/<span class="number">100</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, redratio.__len__() + <span class="number">1</span>, <span class="number">1</span>)],redratio, <span class="string">&#x27;-ob&#x27;</span>, label=<span class="string">&quot;Reduction ratio&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">ax2.legend(loc=<span class="string">&#x27;lower right&#x27;</span>)</span><br><span class="line">plt.suptitle(<span class="string">f&#x27;Max average deviation reduction ratio:<span class="subst">&#123;np.array(redratio).<span class="built_in">max</span>()*<span class="number">100</span>:<span class="number">.3</span>f&#125;</span>% at <span class="subst">&#123;(np.array(redratio).argmax() + <span class="number">1</span>)/<span class="number">100</span>&#125;</span>&#x27;</span>)</span><br><span class="line">plt.plot(np.array(redratio).argmax()/<span class="number">100</span> , np.array(redratio).<span class="built_in">max</span>(), <span class="string">&#x27;*g&#x27;</span>, markersize=<span class="number">10</span>)</span><br><span class="line">plt.axhline(np.array(redratio).<span class="built_in">max</span>(), color=<span class="string">&#x27;r&#x27;</span>)</span><br></pre></td></tr></table></figure><p><imgsrc="/images/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_files/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_30_1.png" /></p><h2 id="适应性矩估计-adam-adaptive-moment-estimation">1.5 适应性矩估计(ADAM, adaptive moment estimation)</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">moveFilter = MAF.AdaptivemDmentEstimation(<span class="number">0.96</span>)</span><br><span class="line">FilterValue = moveFilter.refilter(MeasureValue)</span><br><span class="line"><span class="comment">### 绘图展示 ###</span></span><br><span class="line">plt.figure(figsize=(<span class="number">25</span>, <span class="number">5</span>))</span><br><span class="line">plt.plot(ModelValue, <span class="string">&#x27;.-&#x27;</span>, label=<span class="string">&quot;Model&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(ActualValue, <span class="string">&#x27;*-&#x27;</span>, label=<span class="string">&quot;Actual&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(MeasureValue, <span class="string">&#x27;-&#x27;</span>, label=<span class="string">&quot;Measure&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(FilterValue, <span class="string">&#x27;o-&#x27;</span>, label=<span class="string">&quot;Filter&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower right&#x27;</span>) <span class="comment">#绘制图例</span></span><br><span class="line">FP.FilterPerformance.analysis(FilterValue, MeasureValue, ActualValue)</span><br></pre></td></tr></table></figure><p><imgsrc="/images/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_files/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_32_0.png" /></p><p><imgsrc="/images/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_files/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_32_1.png" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">bias0    = []</span><br><span class="line">bias1    = []</span><br><span class="line">redratio = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">20000</span>, <span class="number">1</span>):</span><br><span class="line">    moveFilter = MAF.AdaptivemDmentEstimation(i/<span class="number">10000</span>)</span><br><span class="line">    FilterValue = moveFilter.refilter(MeasureValue)</span><br><span class="line">    bias0.append(np.mean(<span class="built_in">abs</span>(np.array(MeasureValue) - np.array(ActualValue))))</span><br><span class="line">    bias1.append(np.mean(<span class="built_in">abs</span>(np.array(FilterValue) - np.array(ActualValue))))</span><br><span class="line">    redratio.append(<span class="number">1</span> - bias1[-<span class="number">1</span>] / bias0[-<span class="number">1</span>])</span><br><span class="line">fig = plt.figure(figsize=figsize)</span><br><span class="line">ax = fig.add_subplot(<span class="number">111</span>)</span><br><span class="line">ax.plot([i/<span class="number">10000</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, bias1.__len__() + <span class="number">1</span>, <span class="number">1</span>)], bias1, <span class="string">&#x27;-o&#x27;</span>, label=<span class="string">&quot;Mean abs bias&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">ax.legend(loc=<span class="string">&#x27;lower left&#x27;</span>)</span><br><span class="line">ax2 = ax.twinx()</span><br><span class="line">ax2.plot([i/<span class="number">10000</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, bias1.__len__() + <span class="number">1</span>, <span class="number">1</span>)],redratio, <span class="string">&#x27;-ob&#x27;</span>, label=<span class="string">&quot;Reduction ratio&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">ax2.legend(loc=<span class="string">&#x27;lower right&#x27;</span>)</span><br><span class="line">plt.suptitle(<span class="string">f&#x27;Max average deviation reduction ratio:<span class="subst">&#123;np.array(redratio).<span class="built_in">max</span>()*<span class="number">100</span>:<span class="number">.3</span>f&#125;</span>% at <span class="subst">&#123;(np.array(redratio).argmax() + <span class="number">1</span>)/<span class="number">10000</span>&#125;</span>&#x27;</span>)</span><br><span class="line">plt.plot(np.array(redratio).argmax()/<span class="number">10000</span> , np.array(redratio).<span class="built_in">max</span>(), <span class="string">&#x27;*g&#x27;</span>, markersize=<span class="number">10</span>)</span><br><span class="line">plt.axhline(np.array(redratio).<span class="built_in">max</span>(), color=<span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"><span class="comment"># x = x = np.outer(np.linspace(0, 1, 100), np.ones(100))</span></span><br><span class="line"><span class="comment"># y = x.copy().T</span></span><br><span class="line"><span class="comment"># z = np.zeros((100, 100))</span></span><br><span class="line"><span class="comment"># zz = []</span></span><br><span class="line"><span class="comment"># for k in range(100, 200, 1):</span></span><br><span class="line"><span class="comment">#     for i in range(1, 100, 1):</span></span><br><span class="line"><span class="comment">#         beta1 = i/100</span></span><br><span class="line"><span class="comment">#         for j in range(1, 100, 1):</span></span><br><span class="line"><span class="comment">#             beta2 = j/100</span></span><br><span class="line"><span class="comment">#             moveFilter = MAF.AdaptivemDmentEstimation(k/100)</span></span><br><span class="line"><span class="comment">#             FilterValue = moveFilter.refilter(MeasureValue)</span></span><br><span class="line"><span class="comment">#             bias0 = np.mean(abs(np.array(MeasureValue) - np.array(ActualValue)))</span></span><br><span class="line"><span class="comment">#             bias1 = np.mean(abs(np.array(FilterValue) - np.array(ActualValue)))</span></span><br><span class="line"><span class="comment">#             z[i][j] = (1 - (bias1 / bias0))</span></span><br><span class="line"><span class="comment">#             zz.append(z.max())</span></span><br><span class="line"><span class="comment"># fig = plt.figure(figsize=(20, 20))</span></span><br><span class="line"><span class="comment"># ax = plt.axes(projection=&#x27;3d&#x27;)</span></span><br><span class="line"><span class="comment"># ax.plot_surface(x, y, z)</span></span><br><span class="line"><span class="comment"># print(z.max())</span></span><br><span class="line"><span class="comment"># print(np.array(zz).max())</span></span><br></pre></td></tr></table></figure><p><imgsrc="/images/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_files/1_1.%E6%BB%91%E5%8A%A8%E6%BB%A4%E6%B3%A2_33_1.png" /></p><h2 id="参考文献">2 参考文献</h2><p><a href="https://www.lamda.nju.edu.cn/yehj/tsa2022/">Han-Jia Ye. TimeSeries Analysis. 2022</a><br /><a href="https://arxiv.org/pdf/1412.6980">Diederik P. Kingma and JimmyBa, Adam: A Method for Stochastic Optimization[C], 2017,1412(6980)</a><br /><ahref="https://z.library.sh.cn/next/resource/eds/detail?vid=e_ZWRzanNy%23ZWRzanNyLjE2NjgxNA%3D%3D">Brown.Robert G. et al, The Fundamental Theorem of Exponential Smoothing[J],1961, 9(5): 673–687</a></p>]]></content>
      
      
      <categories>
          
          <category> 贝叶斯滤波器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滤波器 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贝叶斯滤波器系列(1) - Hello Filter</title>
      <link href="/2025/09/01/BF01/"/>
      <url>/2025/09/01/BF01/</url>
      
        <content type="html"><![CDATA[<h1 id="hallo-filter">Hallo Filter</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment"># %matplotlib ipympl</span></span><br><span class="line"><span class="comment"># %matplotlib widget</span></span><br><span class="line"></span><br><span class="line">figsize=(<span class="number">20</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h3 id="噪声的数学模型">1 噪声的数学模型</h3><p>先来回想一下，小学数学里测量一个物体的长度、重量巴拉巴拉等物理量时为了减小误差的方法是————多次测量取平均值。所以多次测量取平均值是怎么减小误差的呢？</p><h4 id="噪声建模">1.1 噪声建模</h4><p><strong>中心极限定理</strong>告诉我们:只要随机变量相互独立，每个随机变量对和的影响都是微小的，哪怕它们的分布类型不同，其和标准化后都有标准正态的极限分布。话句话说，某一事件受到许多相互独立且微小的随机因素影响，总的影响就可以看作服从或近似服从正态分布。<br />不妨来仿真一下，下述代码测试计算了 50000 次随机事件，每次随机事件均为100 次平均分布的随机变量之和。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制标准正态分布曲线</span></span><br><span class="line">u = <span class="number">0</span></span><br><span class="line">sig = math.sqrt(<span class="number">1</span>)</span><br><span class="line">x = np.linspace(u - <span class="number">3</span>*sig, u + <span class="number">3</span>*sig)</span><br><span class="line">y = np.exp(-(x - u) ** <span class="number">2</span> / (<span class="number">2</span> * sig ** <span class="number">2</span>)) / (math.sqrt(<span class="number">2</span>*math.pi)*sig)</span><br><span class="line">plt.figure(figsize=figsize)</span><br><span class="line">plt.plot(x, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 中心极限定理仿真</span></span><br><span class="line">a = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50000</span>):</span><br><span class="line">    a.append(np.<span class="built_in">sum</span>(np.random.uniform(<span class="number">10</span>, <span class="number">20</span>, <span class="number">100</span>)))</span><br><span class="line">a = (a - np.average(a)) / np.std(a)</span><br><span class="line">plt.hist(a, <span class="number">100</span>, density=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><img src="/images/BF01/HalloFilter_3_1.png" /></p><p>非常amazing啊！均匀分布的随机事件频率分布直方图竟然被标准正态分布函数完美的包络了。<br />这便是正态分布在生活中如此常见的原因。继续以测量误差为例，其受到许多相互独立随机因素的影响，如测量环境温度、湿度，测量工具的精密程度以及测量者的心理因素、测量的态度等的影响，而每种影响都不占主要地位，那么它们总和造成的总误差就近似地服从正态分布。</p><h4 id="多次测量的作用">1.2 多次测量的作用</h4><p>现在我们知道误差在数学上的模型了，但多次测量为什么能减小误差呢？(严谨一点的话应该是把问题转化为：证明若干正态分布随机变量均值的方差比每个单独的随机变量都要小。然后多维随机变量积分出来方差。但我懒🤓)<br />假设测量是一个随机试验，那么多次测量结果是相互独立的。由正态分布的性质可知，相互独立的正态分布之和仍然是正态分布，于是我们有<span class="math display">$$\begin{align}                                       \nonumber   Y=\sum{X_i}&amp;\sim(\sum{\mu_i},\sum{\sigma_i^2})\\         \nonumber   Y&amp;\sim(n\mu,n\sigma^2)\\                           \nonumber   \hat{X}=Y/n&amp;\sim(\mu,\frac{\sigma^2}{n})                  \end{align}                                     $$</span>不难看出，方差与次数成反比。所以，随测量次数的增加方差会快速下降。如果你觉得不够直观的话不妨用概率来描述，由切比雪夫不等式<span class="math display">$$P\{|X-E(X)| \geq \varepsilon\} \leq \frac{D(X)}{\varepsilon^{2}}$$</span> 可知，事件 “随机变量 X 关于其期望产生了偏差 ε”发生的概率上限为 <span class="math display">$$P=\frac{D(X)}{\varepsilon^{2}} = \frac{1}{n} \cdot\frac{\sigma^2}{\varepsilon^{2}}$$</span> 可见，发生偏差的概率的概率上限也是成反比下降的。不妨令 <spanclass="math inline"><em>n</em> = <em>k</em>/<em>ε</em><sup>2</sup></span>于是有 <span class="math display">$$P= \frac{\sigma^2}{k}$$</span> 这就是说，当实验次数为 <spanclass="math inline">$\frac{k}{ε^2}$</span> 时，随机变量 X关于其期望产生了偏差 ε为 $ $</p><blockquote><p><em>(PS:这部分全是概率论与数理统计课本上的东西，甚至没任何形式变化，完全就是定义。这要是都看着吃力的话，建议重修。)</em></p></blockquote><blockquote><p>从直观感觉上来说的话，每次测量都包含了“信息”。每一次新的测量都代表了“新息”的进入，多次测量使得系统的信息增多，不确定性下降，从而使得新息的信息熵降低。在这个角度上倒是很容易理解为什么多次测量的边际效应会十分显著了。</p></blockquote><h3 id="滤波器初体验">2 滤波器初体验</h3><h4 id="滤波器仿真">2.1 滤波器仿真</h4><p>对于一个静态系统来说，也没什么花里胡哨的玩法，暴力求平均即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 模型参数 ###</span></span><br><span class="line"><span class="comment"># 采样参数</span></span><br><span class="line">SampleFre = <span class="number">10</span></span><br><span class="line">TotalTime = <span class="number">10</span></span><br><span class="line">Step = <span class="number">1</span>/SampleFre</span><br><span class="line">SampleNum = SampleFre * TotalTime</span><br><span class="line"></span><br><span class="line"><span class="comment">#观测序列</span></span><br><span class="line">ActualValue = []        <span class="comment">#实际值</span></span><br><span class="line">MeasureValue = []       <span class="comment">#测量值</span></span><br><span class="line">FilterValue = []        <span class="comment">#滤波值</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 仿真 ###</span></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> x &lt; TotalTime:</span><br><span class="line">    temp = <span class="number">1</span>                                <span class="comment">#实际值</span></span><br><span class="line">    ActualValue.append(temp)</span><br><span class="line"></span><br><span class="line">    temp = np.random.normal(temp, <span class="number">1</span>)      <span class="comment">#测量值 </span></span><br><span class="line">    MeasureValue.append(temp)</span><br><span class="line"></span><br><span class="line">    FilterValue.append(np.average(MeasureValue)) <span class="comment">#滤波值</span></span><br><span class="line"></span><br><span class="line">    x += Step</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 绘图展示 ###</span></span><br><span class="line">plt.figure(figsize=figsize)</span><br><span class="line">plt.plot(ActualValue, <span class="string">&#x27;*-&#x27;</span>, label=<span class="string">&quot;Actual&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(MeasureValue, <span class="string">&#x27;o-&#x27;</span>, label=<span class="string">&quot;Measure&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(FilterValue, <span class="string">&#x27;.-&#x27;</span>, label=<span class="string">&quot;Filter&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower right&#x27;</span>) <span class="comment">#绘制图例</span></span><br></pre></td></tr></table></figure><p><img src="/images/BF01/HalloFilter_8_1.png" /></p><p>emmmmmm 效果不错…吧？<br />随着次数的增多”感觉”误差越来越小了，但该怎么用数学语言描述呢？<br />&gt; 1.事物的好坏、多少等等，都是定性分析，是有潜在参考标准的，单独讨论没有任何意义。作为工程师，我们需要将定性分析转化为定量分析，具体的去分析某种事物的性能。<br />记得高中学集合时老师举的一个例子：“把所有高个子的人记作一个集合”，这种说法是错误的。因为高是一个相对词，正确的说法应该是所有身高大于180cm 的人记作一个集合。<br />&gt; 2.任何改进都一定会引入新的缺点，但往往我们只关注某一方面的性能，在另一方面上的缺点是可以被忽略的。所以在工程上千万不要有强者恒强的想法，而是要根据情况具体分析后选择最优的解法。</p><h4 id="滤波器性能的分析">2.2 滤波器性能的分析</h4>再回到概率论的内容，有这么一个量，它可以描述两个具有相等期望事件的稳定性，他就是————<del>二阶中心距</del>，人话：方差。&gt; 1) 用偏差来描述：<spanclass="math inline"><em>X</em> − <em>E</em>(<em>X</em>)</span> —–&gt;偏差存在正负 &gt; 2) 消去符号：<spanclass="math inline">|<em>X</em>−<em>E</em>(<em>X</em>)|</span>—(使其便于数学处理)—&gt; <spanclass="math inline">(<em>X</em>−<em>E</em>(<em>X</em>))<sup>2</sup></span>&gt; 3) 注意到处理后仍是随机变量而非数字特征，于是 <spanclass="math inline"><em>E</em>[(<em>X</em>−<em>E</em>(<em>X</em>))<sup>2</sup>]</span>，称其为方差。&gt; 4)在工程上，方差的量纲为随机变量量纲的平方，不便于使用，习惯上取其算数平方根，称为标准差或均方差。&gt;<p align="right">————《莪哋薮敩毣汜》沃·兹基谢德</p><p>上面已经说过了，取平方的意义只是为了便于数学处理而已。毕竟 abs(x)不是一个初等函数，但 <span class="math inline">$\sqrt{x^2}$</span>却是初等函数。在应用中直接用偏差的绝对值来描述即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#观测序列</span></span><br><span class="line">ActualValue = []        <span class="comment">#实际值</span></span><br><span class="line">MeasureValue = []       <span class="comment">#测量值</span></span><br><span class="line">err0 = []                <span class="comment">#误差</span></span><br><span class="line">err1 = []                <span class="comment">#误差</span></span><br><span class="line">std0 = []                <span class="comment">#标准差</span></span><br><span class="line">std1 = []                <span class="comment">#标准差</span></span><br><span class="line">FilterValue = []        <span class="comment">#滤波值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### 仿真 ###</span></span><br><span class="line">x = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> x &lt; TotalTime:</span><br><span class="line">    trueValue = <span class="number">1</span></span><br><span class="line">    ActualValue.append(trueValue)</span><br><span class="line"></span><br><span class="line">    temp = np.random.normal(trueValue, <span class="number">10</span>)      <span class="comment">#测量值 </span></span><br><span class="line">    MeasureValue.append(temp)</span><br><span class="line">    err0.append(np.<span class="built_in">abs</span>(temp - trueValue))   <span class="comment">#误差</span></span><br><span class="line"></span><br><span class="line">    temp = np.average(MeasureValue)         <span class="comment">#滤波值</span></span><br><span class="line">    FilterValue.append(temp)</span><br><span class="line">    std0.append(np.std(MeasureValue)/np.sqrt(np.size(MeasureValue)) * stats.t.isf(<span class="number">0.025</span>, np.size(err0)))<span class="comment"># 95%置信区间</span></span><br><span class="line"></span><br><span class="line">    err1.append(np.<span class="built_in">abs</span>(temp - ActualValue[-<span class="number">1</span>]))   <span class="comment">#误差</span></span><br><span class="line">    std1.append(np.std(MeasureValue)/np.sqrt(np.size(MeasureValue)) * stats.t.isf(<span class="number">0.025</span>, np.size(err1)))<span class="comment"># 95%置信区间</span></span><br><span class="line"></span><br><span class="line">    x += Step</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### 绘图展示 ###</span></span><br><span class="line">plt.figure(figsize=figsize)</span><br><span class="line">plt.plot(ActualValue, <span class="string">&#x27;*-&#x27;</span>, label=<span class="string">&quot;Actual&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.plot(MeasureValue, <span class="string">&#x27;o-&#x27;</span>, label=<span class="string">&quot;Measure&quot;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.errorbar(<span class="built_in">range</span>(<span class="number">0</span>, np.size(FilterValue)), FilterValue, yerr=std0, label=<span class="string">&quot;Filter&quot;</span>, fmt=<span class="string">&#x27;.-&#x27;</span>, capthick=<span class="number">2</span>, capsize=<span class="number">10</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower right&#x27;</span>) <span class="comment">#绘制图例</span></span><br><span class="line"></span><br><span class="line">plt.figure(figsize=figsize)</span><br><span class="line">plt.plot(err0, <span class="string">&#x27;*-&#x27;</span>, label=<span class="string">&quot;Measure Error&quot;</span>)</span><br><span class="line">plt.errorbar(<span class="built_in">range</span>(<span class="number">0</span>, np.size(err1)), err1, yerr=std1, label=<span class="string">&quot;Filter Error&quot;</span>, fmt=<span class="string">&#x27;.-&#x27;</span>, capthick=<span class="number">2</span>, capsize=<span class="number">10</span>)</span><br><span class="line">plt.plot([<span class="number">0</span> <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, np.size(err1))], <span class="string">&#x27;-&#x27;</span>, markersize=<span class="number">5</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower right&#x27;</span>) <span class="comment">#绘制图例</span></span><br></pre></td></tr></table></figure><p><img src="/images/BF01/HalloFilter_11_1.png" /></p><p><img src="/images/BF01/HalloFilter_11_2.png" /></p><p>多运行几次后，大致可以总结成：<br />- 前期一般收敛较快。 - 误差的绝对值并不总是一直减小的。</p><h4 id="递推形式">2.3 递推形式</h4><p><span class="math display">$$\begin{align}    \nonumber   \bar{x} &amp; = \frac{\sum_{i=1}^{n}{x_i}}{n}\\    \nonumber   \bar{x} &amp; =\frac{\sum_{i=1}^{n-1}{x_i}}{n-1} \cdot\frac{n-1}{n} + \frac{x_n}{n}\\    \nonumber   \bar{x} &amp; = \frac{\bar{x}_{last} \cdot (n-1) +x_n}{n}\\    \nonumber   \bar{x} &amp; = \bar{x}_{last} +\frac{1}{n}(x_n-\bar{x}_{last})\end{align}$$</span> 上述形式的在应用中的优点主要是:</p><ul><li>不需要储存全部的测量值，只需要保存当前次数与平均值即可(int +float)。</li><li>计算次数少，最后的形式只需计算两次加法与一个除法。</li></ul><p>当然，前文提到过任何改进都将引入新的缺点： -计算机的float类型是不可靠的，每次迭代都会带来误差。 -与最开始小学生都会的形式相比递推形式更难了一些。(啥？你说这点难度也算缺点？记住这个形式，以后你还会见到他的🤭)</p><p>让我选择的话，大概绝大多数情况我都会选择递推形式。因为在使用累计平均滤波器时，其目的就是测量一个静态数值。在这种情况下与优点相比较，其缺点几乎是可以忽略的。</p>]]></content>
      
      
      <categories>
          
          <category> 贝叶斯滤波器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滤波器 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python 环境管理</title>
      <link href="/2025/09/01/python%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86/"/>
      <url>/2025/09/01/python%E7%8E%AF%E5%A2%83%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="python-多环境安装">1. python 多环境安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install software-properties-common<span class="comment"># 必要的支持包</span></span><br><span class="line"><span class="built_in">sudo</span> add-apt-repository ppa:deadsnakes/ppa<span class="comment"># Deadsnakes PPA（一个非常好用的第三方软件源）</span></span><br><span class="line"><span class="built_in">sudo</span> apt update</span><br><span class="line"><span class="built_in">sudo</span> apt install python3.11<span class="comment"># 安装指定版本解释器</span></span><br></pre></td></tr></table></figure><h2 id="venv-虚拟环境">2. venv 虚拟环境</h2><p>venv 是 python3自带虚拟环境包。使用十分简单，但是缺少一些较为复杂的功能支持。 ### 2.1虚拟环境的创建 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m venv .venv</span><br></pre></td></tr></table></figure></p><h3 id="虚拟环境的激活">2.2 虚拟环境的激活</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> .venv/bin/activate</span><br></pre></td></tr></table></figure><table><tr><th colspan="3">虚拟环境激活指令</th></tr ><tr><td>平台</td><td>Shell</td><td>用于激活虚拟环境的命令</td></tr ><tr><td rowspan="5">POSIX</td></tr><tr><td>bash/zsh</td><td>source .venv/bin/activate</td></tr><tr><td>csh/tcsh</td><td>source .venv/bin/activate.fish</td></tr><tr><td>pwsh</td><td>source .venv/bin/activate.csh</td></tr><tr><td>bash/zsh</td><td>.venv/bin/Activate.ps1</td></tr><tr><td rowspan="3">Windows</td></tr><tr><td>cmd</td><td>.venv.bat</td></tr><tr><td>PowerShell</td><td>.venv.ps1</td></tr></table><h3 id="虚拟环境的退出">2.3 虚拟环境的退出</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deactivate</span><br></pre></td></tr></table></figure><h3 id="安装依赖可选">2.4 安装依赖(可选)</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><h2 id="virtualenv-虚拟环境">3. virtualenv 虚拟环境</h2><h3 id="安装">安装</h3><p>安装到全局环境中 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install virtualenv --break-system-packages</span><br></pre></td></tr></table></figure></p><h3 id="其他操作">其他操作</h3><p>与 venv 类似这里不再赘述。这里说一下使用指定版本解释器初始化虚拟环境<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtualenv .venv -p python3.11</span><br></pre></td></tr></table></figure></p><h3 id="参考文献">参考文献</h3><blockquote><p>https://docs.python.org/zh-cn/3.12/library/venv.html</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> venv </tag>
            
            <tag> 虚拟环境 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟磁盘创建与挂载</title>
      <link href="/2025/08/31/%E8%99%9A%E6%8B%9F%E7%A3%81%E7%9B%98%E5%88%B6%E4%BD%9C/"/>
      <url>/2025/08/31/%E8%99%9A%E6%8B%9F%E7%A3%81%E7%9B%98%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h4 id="环境wsl-ubuntu-24.04-lts"><strong><em>环境：WSL-Ubuntu 24.04LTS</em></strong></h4><h2 id="创建空文件">1. 创建空文件</h2><p>执行下述命令将在工作目录下创建一个大小为 SIZE[Mb] 空文件<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=&lt;filename&gt; bs=1024 count=SIZE</span><br></pre></td></tr></table></figure></p><h2 id="格式化映像文件">2. 格式化映像文件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt install dosfstools <span class="comment">#安装 fat 的格式化工具</span></span><br><span class="line">mkfs.vfat &lt;filename&gt; <span class="comment">#格式化该文件为 fat 文件系统</span></span><br><span class="line">mount -o loop &lt;filename&gt; /mnt <span class="comment">#挂载文件</span></span><br></pre></td></tr></table></figure><p>如果出现类似错误： mount: /mnt/sdcard/: failed to setup loop devicefor /home/reglucis/project/YueShell/Middleware/VirtualFlash/sdcard.vfs.记得 sudo……😓</p><h2 id="使用">3. 使用</h2><p>现在应该就可以在 /mnt 文件夹访问这一虚拟磁盘了，也可以通过 windows的文件资源管理器访问。 代码层面则可以使用 virtualDisk + FatFs来访问该磁盘。 类似的，也可以将其他文件系统映像传输至本地计算机来加载。&gt; 有了这一项技术，开发调试文件系统简单方便了不少。</p>]]></content>
      
      
      <categories>
          
          <category> 虚拟磁盘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FileSystem </tag>
            
            <tag> FatFs </tag>
            
            <tag> WSL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 新建文章</title>
      <link href="/2025/08/30/Hexo%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0/"/>
      <url>/2025/08/30/Hexo%E6%96%B0%E5%BB%BA%E6%96%87%E7%AB%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="准备工作">准备工作</h2><h3 id="创建分类选项">创建“分类”选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page categories</span><br></pre></td></tr></table></figure><p>打开文件，并修改 <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line"><span class="section">date: 2017-05-27 13:47:40</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">&lt;修改为&gt;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: 文章分类</span><br><span class="line">date: 2017-05-27 13:47:40</span><br><span class="line"><span class="section">type: &quot;categories&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure></p><h3 id="创建标签选项">创建“标签”选项</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page tags</span><br></pre></td></tr></table></figure><p>打开文件，并修改 <figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line"><span class="section">date: 2025-08-30 22:39:50</span></span><br><span class="line"><span class="section">---</span></span><br><span class="line"></span><br><span class="line">&lt;修改为&gt;</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">title: tags</span><br><span class="line">date: 2025-08-30 22:39:50</span><br><span class="line"><span class="section">type: &quot;tags&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure></p><h2 id="开始-hero-的第一篇文章">开始 Hero 的第一篇文章</h2><h3 id="新建文章">新建文章</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;标题&quot;</span></span><br></pre></td></tr></table></figure><p>打开文件后可以先看到如下内容 &gt; title: 标题 &gt; date: 2025-08-3022:06:13 &gt; tags:</p><h3 id="添加分类">添加分类</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">categories: </span><br><span class="line"><span class="bullet">-</span> aaaa</span><br></pre></td></tr></table></figure><h3 id="添加标签">添加标签</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tags: </span><br><span class="line"><span class="bullet">-</span> aaaa</span><br><span class="line"><span class="bullet">-</span> bbbb</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github_page + Hexo 建立个人博客</title>
      <link href="/2025/08/30/%E5%BB%BA%E7%AB%99/"/>
      <url>/2025/08/30/%E5%BB%BA%E7%AB%99/</url>
      
        <content type="html"><![CDATA[<h2 id="github-page-相关配置">1. Github page 相关配置</h2><p>详见 github 文档 &gt; https://docs.github.com/en/pages/quickstart</p><h2 id="安装-node.js">2. 安装 Node.js</h2><p><em>环境：WSL-Ubuntu 24.04 LTS</em> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装 nvm #</span></span><br><span class="line"><span class="built_in">sudo</span> apt-get install curl</span><br><span class="line">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/master/install.sh | bash</span><br><span class="line"><span class="comment">## (重启)</span></span><br><span class="line"><span class="comment"># 安装 Node.js LTS 版本 #</span></span><br><span class="line">nvm install --lts</span><br><span class="line">node --version<span class="comment">## 验证 node </span></span><br><span class="line">npm version<span class="comment">## 验证 npm </span></span><br></pre></td></tr></table></figure> &gt;https://learn.microsoft.com/zh-cn/windows/dev-environment/javascript/nodejs-on-wsl</p><h2 id="部署-hexo-及其插件">3. 部署 Hexo 及其插件</h2><h3 id="安装-hexo">3.1 安装 Hexo</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line">hexo version<span class="comment">## 验证</span></span><br></pre></td></tr></table></figure><h3 id="初始化-hexo-仓库及安装插件">3.2 初始化 Hexo 仓库及安装插件</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo init &lt;your-folder-name&gt;<span class="comment"># 将文件夹名替换为你的，例如 hexo init reglucis.github.io</span></span><br><span class="line"><span class="built_in">cd</span> &lt;your-folder-name&gt;</span><br><span class="line">npm install</span><br><span class="line">npm install hexo-deployer-git save<span class="comment"># 安装插件 hexo-deployer-git (使用 GitHub Pages 功能需要)</span></span><br></pre></td></tr></table></figure><p>安装好后可在本地启动服务器，预览网站 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server -o</span><br></pre></td></tr></table></figure>出现下述状态即为成功。 <img src="/images/PixPin_2025-08-30_20-05-18.png"alt="图片" /></p><h2 id="设置部署仓库和分支">4. 设置部署仓库和分支</h2><p>打开仓库根目录的 _config.yml <figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#（修改为）</span></span><br><span class="line"></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="comment"># rebo 填写你自己仓库的 ssh 连接</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:Reglucis/Reglucis.github.io.git</span></span><br><span class="line">  <span class="comment"># branch 要与你在仓库设置页指定的分支相同</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h2 id="生成静态网页并发布">4. 生成静态网页并发布</h2><p>生成静态网页文件 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure> <em>生成后，静态网页保存在 public文件夹中.</em> 推送</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
